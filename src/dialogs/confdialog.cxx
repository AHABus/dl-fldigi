// generated by Fast Light User Interface Designer (fluid) version 1.0108

#include "confdialog.h"
#include <config.h>
#include <FL/Fl_Tooltip.H>
#include "main.h"
#include "soundconf.h"
#include "combo.h"
#include "colorsfonts.h"
#include "waterfall.h"
#include "rigxml.h"
#include "lookupcall.h"
#include "icons.h"
#include "Viewer.h"
#include "pskrep.h"
extern void initViewer();
Fl_Double_Window *dlgConfig; 

void set_qrz_buttons(Fl_Button* b) {
  Fl_Button* qrzb[] = { btnQRZnotavailable, btnQRZcdrom, btnQRZonline,
                              btnQRZsub, btnHamcall};

for (size_t i = 0; i < sizeof(qrzb)/sizeof(*qrzb); i++)
	qrzb[i]->value(b == qrzb[i]);
}

Fl_Tabs *tabsConfigure=(Fl_Tabs *)0;

Fl_Group *tabID=(Fl_Group *)0;

Fl_Check_Button *btnsendid=(Fl_Check_Button *)0;

static void cb_btnsendid(Fl_Check_Button* o, void*) {
  progdefaults.sendid=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnsendvideotext=(Fl_Check_Button *)0;

static void cb_btnsendvideotext(Fl_Check_Button* o, void*) {
  progdefaults.sendtextid=o->value();
progdefaults.changed = true;
}

Fl_Input *valVideotext=(Fl_Input *)0;

static void cb_valVideotext(Fl_Input* o, void*) {
  progdefaults.strTextid = o->value();
progdefaults.changed = true;
}

Fl_Value_Slider *sldrVideowidth=(Fl_Value_Slider *)0;

static void cb_sldrVideowidth(Fl_Value_Slider* o, void*) {
  progdefaults.videowidth = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkID_SMALL=(Fl_Check_Button *)0;

static void cb_chkID_SMALL(Fl_Check_Button* o, void*) {
  progdefaults.ID_SMALL=o->value();
if (o->value() == 1)
sldrVideowidth->deactivate();
else
sldrVideowidth->activate();
progdefaults.changed = true;
}

Fl_Group *sld=(Fl_Group *)0;

Fl_Check_Button *btnCWID=(Fl_Check_Button *)0;

static void cb_btnCWID(Fl_Check_Button* o, void*) {
  progdefaults.CWid = o->value();
progdefaults.changed = true;
}

Fl_Value_Slider *sldrCWIDwpm=(Fl_Value_Slider *)0;

static void cb_sldrCWIDwpm(Fl_Value_Slider* o, void*) {
  progdefaults.CWIDwpm = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkTransmitRSid=(Fl_Check_Button *)0;

static void cb_chkTransmitRSid(Fl_Check_Button* o, void*) {
  progdefaults.TransmitRSid = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkRSidWideSearch=(Fl_Check_Button *)0;

static void cb_chkRSidWideSearch(Fl_Check_Button* o, void*) {
  progdefaults.rsidWideSearch=o->value();
progdefaults.changed = true;
}

Fl_Group *tabMisc=(Fl_Group *)0;

Fl_Tabs *tabsMisc=(Fl_Tabs *)0;

Fl_Group *tabCPUspeed=(Fl_Group *)0;

Fl_Check_Button *chkSlowCpu=(Fl_Check_Button *)0;

static void cb_chkSlowCpu(Fl_Check_Button* o, void*) {
  progdefaults.slowcpu = o->value();
progdefaults.changed = true;
}

Fl_Group *tabMacros=(Fl_Group *)0;

Fl_Check_Button *btnUseLastMacro=(Fl_Check_Button *)0;

static void cb_btnUseLastMacro(Fl_Check_Button* o, void*) {
  progdefaults.UseLastMacro = o->value();
update_main_title();
progdefaults.changed = true;
}

Fl_Check_Button *btnDisplayMacroFilename=(Fl_Check_Button *)0;

static void cb_btnDisplayMacroFilename(Fl_Check_Button* o, void*) {
  progdefaults.DisplayMacroFilename = o->value();
progdefaults.changed = true;
}

Fl_Group *tabSweetSpot=(Fl_Group *)0;

Fl_Value_Input *valCWsweetspot=(Fl_Value_Input *)0;

static void cb_valCWsweetspot(Fl_Value_Input* o, void*) {
  progdefaults.CWsweetspot=o->value();
progdefaults.changed = true;
}

Fl_Value_Input *valRTTYsweetspot=(Fl_Value_Input *)0;

static void cb_valRTTYsweetspot(Fl_Value_Input* o, void*) {
  progdefaults.RTTYsweetspot=o->value();
progdefaults.changed = true;
}

Fl_Value_Input *valPSKsweetspot=(Fl_Value_Input *)0;

static void cb_valPSKsweetspot(Fl_Value_Input* o, void*) {
  progdefaults.PSKsweetspot=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnStartAtSweetSpot=(Fl_Check_Button *)0;

static void cb_btnStartAtSweetSpot(Fl_Check_Button* o, void*) {
  progdefaults.StartAtSweetSpot = o->value();
progdefaults.changed = true;
}

Fl_Group *tabSpot=(Fl_Group *)0;

Fl_Check_Button *btnPSKRepAuto=(Fl_Check_Button *)0;

static void cb_btnPSKRepAuto(Fl_Check_Button* o, void*) {
  progdefaults.pskrep_auto = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Check_Button *btnPSKRepLog=(Fl_Check_Button *)0;

static void cb_btnPSKRepLog(Fl_Check_Button* o, void*) {
  progdefaults.pskrep_log = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Input *inpPSKRepHost=(Fl_Input *)0;

static void cb_inpPSKRepHost(Fl_Input* o, void*) {
  progdefaults.pskrep_host = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Input *inpPSKRepPort=(Fl_Input *)0;

static void cb_inpPSKRepPort(Fl_Input* o, void*) {
  progdefaults.pskrep_port = o->value();
btnPSKRepInit->labelcolor(FL_RED);
btnPSKRepInit->redraw_label();
progdefaults.changed = true;
}

Fl_Button *btnPSKRepInit=(Fl_Button *)0;

static void cb_btnPSKRepInit(Fl_Button* o, void*) {
  pskrep_stop();
if (!pskrep_start()) {
    boxPSKRepMsg->copy_label(pskrep_error());
    progdefaults.usepskrep = false;
} else {
    boxPSKRepMsg->label(0);
    o->labelcolor(FL_FOREGROUND_COLOR);
    progdefaults.usepskrep = true;
}
progdefaults.changed = true;
}

Fl_Box *boxPSKRepMsg=(Fl_Box *)0;

Fl_Check_Button *btnPSKRepQRG=(Fl_Check_Button *)0;

static void cb_btnPSKRepQRG(Fl_Check_Button* o, void*) {
  progdefaults.pskrep_qrg = o->value();
progdefaults.changed = true;
}

Fl_Group *tabModems=(Fl_Group *)0;

Fl_Tabs *tabsModems=(Fl_Tabs *)0;

Fl_Group *tabCW=(Fl_Group *)0;

Fl_Value_Slider *sldrCWbandwidth=(Fl_Value_Slider *)0;

static void cb_sldrCWbandwidth(Fl_Value_Slider* o, void*) {
  progdefaults.CWbandwidth = (int)o->value();
progdefaults.changed = true;
}

Fl_Counter *cntCWrange=(Fl_Counter *)0;

static void cb_cntCWrange(Fl_Counter* o, void*) {
  progdefaults.CWrange = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCWrcvTrack=(Fl_Check_Button *)0;

static void cb_btnCWrcvTrack(Fl_Check_Button* o, void*) {
  progdefaults.CWtrack = o->value();
progdefaults.changed = true;
}

Fl_Value_Output *valCWrcvWPM=(Fl_Value_Output *)0;

static void cb_valCWrcvWPM(Fl_Value_Output*, void*) {
  progdefaults.changed = true;
}

Fl_Progress *prgsCWrcvWPM=(Fl_Progress *)0;

Fl_Value_Slider *sldrCWxmtWPM=(Fl_Value_Slider *)0;

static void cb_sldrCWxmtWPM(Fl_Value_Slider* o, void*) {
  progdefaults.CWspeed = (int)o->value();
cntPreTiming->maximum((int)(2400/o->value())/2.0);
cntPostTiming->maximum((int)(2400/o->value())/2.0);
progdefaults.changed = true;
}

Fl_Counter *cntCWlowerlimit=(Fl_Counter *)0;

static void cb_cntCWlowerlimit(Fl_Counter* o, void*) {
  progdefaults.CWlowerlimit = (int)o->value();
progdefaults.changed = true;
sldrCWxmtWPM->minimum(o->value());
sldrCWxmtWPM->value(progdefaults.CWspeed);
sldrCWxmtWPM->redraw();
cntCWupperlimit->minimum(o->value()+20);
}

Fl_Counter *cntCWupperlimit=(Fl_Counter *)0;

static void cb_cntCWupperlimit(Fl_Counter* o, void*) {
  progdefaults.CWupperlimit = (int)o->value();
progdefaults.changed = true;
sldrCWxmtWPM->maximum(o->value());
sldrCWxmtWPM->value(progdefaults.CWspeed);
sldrCWxmtWPM->redraw();
cntCWlowerlimit->maximum(o->value()-20);
}

Fl_Counter *cntCWdefWPM=(Fl_Counter *)0;

static void cb_cntCWdefWPM(Fl_Counter* o, void*) {
  progdefaults.defCWspeed = (int)o->value();
progdefaults.changed = true;
}

Fl_Counter *cntCWweight=(Fl_Counter *)0;

static void cb_cntCWweight(Fl_Counter* o, void*) {
  progdefaults.CWweight=(int)o->value();
progdefaults.changed = true;
}

Fl_Counter *cntCWdash2dot=(Fl_Counter *)0;

static void cb_cntCWdash2dot(Fl_Counter* o, void*) {
  progdefaults.CWdash2dot=o->value();
progdefaults.changed = true;
}

Fl_Counter *cntCWrisetime=(Fl_Counter *)0;

static void cb_cntCWrisetime(Fl_Counter* o, void*) {
  progdefaults.CWrisetime=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnQSK=(Fl_Check_Button *)0;

static void cb_btnQSK(Fl_Check_Button* o, void*) {
  progdefaults.QSK=o->value();
progdefaults.changed = true;
}

Fl_Counter *cntPreTiming=(Fl_Counter *)0;

static void cb_cntPreTiming(Fl_Counter* o, void*) {
  progdefaults.CWpre=o->value();
progdefaults.changed = true;
}

Fl_Counter *cntPostTiming=(Fl_Counter *)0;

static void cb_cntPostTiming(Fl_Counter* o, void*) {
  progdefaults.CWpost=o->value();
progdefaults.changed = true;
}

Fl_Group *tabDomEX=(Fl_Group *)0;

Fl_Input *txtSecondary=(Fl_Input *)0;

static void cb_txtSecondary(Fl_Input* o, void*) {
  progdefaults.secText = o->value();
progdefaults.changed = true;
}

Fl_Counter *valDominoEX_BW=(Fl_Counter *)0;

static void cb_valDominoEX_BW(Fl_Counter* o, void*) {
  progdefaults.DOMINOEX_BW = o->value();
resetDOMEX();
progdefaults.changed = true;
}

Fl_Check_Button *valDominoEX_FILTER=(Fl_Check_Button *)0;

static void cb_valDominoEX_FILTER(Fl_Check_Button* o, void*) {
  progdefaults.DOMINOEX_FILTER = o->value();
resetDOMEX();
progdefaults.changed = true;
}

Fl_Check_Button *chkDominoEX_FEC=(Fl_Check_Button *)0;

static void cb_chkDominoEX_FEC(Fl_Check_Button* o, void*) {
  progdefaults.DOMINOEX_FEC = o->value();
progdefaults.changed = true;
}

Fl_Counter *valDominoEX_PATHS=(Fl_Counter *)0;

static void cb_valDominoEX_PATHS(Fl_Counter* o, void*) {
  progdefaults.DOMINOEX_PATHS = (int)o->value();
progdefaults.changed = true;
}

Fl_Value_Slider *valDomCWI=(Fl_Value_Slider *)0;

static void cb_valDomCWI(Fl_Value_Slider* o, void*) {
  progdefaults.DomCWI = o->value();
progdefaults.changed = true;
}

Fl_Group *tabFeld=(Fl_Group *)0;

Fl_Choice *selHellFont=(Fl_Choice *)0;

static void cb_selHellFont(Fl_Choice* o, void*) {
  progdefaults.feldfontnbr=o->value();
progdefaults.changed = true;
}

Fl_Value_Slider *sldrHellBW=(Fl_Value_Slider *)0;

static void cb_sldrHellBW(Fl_Value_Slider*, void*) {
  progdefaults.HELL_BW = sldrHellBW->value();
}

Fl_Check_Button *btnHellXmtWidth=(Fl_Check_Button *)0;

static void cb_btnHellXmtWidth(Fl_Check_Button* o, void*) {
  progdefaults.HellXmtWidth=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnHellRcvWidth=(Fl_Check_Button *)0;

static void cb_btnHellRcvWidth(Fl_Check_Button* o, void*) {
  progdefaults.HellRcvWidth=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnBlackboard=(Fl_Check_Button *)0;

static void cb_btnBlackboard(Fl_Check_Button* o, void*) {
  progdefaults.HellBlackboard=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnHellFastAttack=(Fl_Check_Button *)0;

static void cb_btnHellFastAttack(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
btnHellSlowAttack->value(0);
progdefaults.HellPulseFast = true;
}else{
btnHellSlowAttack->value(1);
progdefaults.HellPulseFast = false;
}
progdefaults.changed = true;
}

Fl_Check_Button *btnHellSlowAttack=(Fl_Check_Button *)0;

static void cb_btnHellSlowAttack(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
btnHellFastAttack->value(0);
progdefaults.HellPulseFast = false;
}else{
btnHellFastAttack->value(1);
progdefaults.HellPulseFast = true;
}
progdefaults.changed = true;
}

Fl_Check_Button *btnFeldHellIdle=(Fl_Check_Button *)0;

static void cb_btnFeldHellIdle(Fl_Check_Button* o, void*) {
  progdefaults.HellXmtIdle=o->value();
progdefaults.changed = true;
}

Fl_Spinner *valHellXmtWidth=(Fl_Spinner *)0;

static void cb_valHellXmtWidth(Fl_Spinner* o, void*) {
  progdefaults.HellXmtWidth=(int)o->value();
progdefaults.changed = true;
}

Fl_Group *tabMT63=(Fl_Group *)0;

Fl_Check_Button *btnMT63_8bit=(Fl_Check_Button *)0;

static void cb_btnMT63_8bit(Fl_Check_Button* o, void*) {
  progdefaults.mt63_8bit = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnmt63_interleave=(Fl_Check_Button *)0;

static void cb_btnmt63_interleave(Fl_Check_Button* o, void*) {
  if (o->value() == 1)
progdefaults.mt63_interleave = 64;
else
progdefaults.mt63_interleave = 32;
progdefaults.changed = true;
}

Fl_Group *tabOlivia=(Fl_Group *)0;

Fl_Choice *mnuOlivia_Tones=(Fl_Choice *)0;

static void cb_mnuOlivia_Tones(Fl_Choice* o, void*) {
  progdefaults.oliviatones = o->value();
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Choice *mnuOlivia_Bandwidth=(Fl_Choice *)0;

static void cb_mnuOlivia_Bandwidth(Fl_Choice* o, void*) {
  progdefaults.oliviabw = o->value();
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Counter *cntOlivia_smargin=(Fl_Counter *)0;

static void cb_cntOlivia_smargin(Fl_Counter* o, void*) {
  progdefaults.oliviasmargin = (int)(o->value());
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Counter *cntOlivia_sinteg=(Fl_Counter *)0;

static void cb_cntOlivia_sinteg(Fl_Counter* o, void*) {
  progdefaults.oliviasinteg = (int)(o->value());
resetOLIVIA();
progdefaults.changed = true;
}

Fl_Check_Button *btnOlivia_8bit=(Fl_Check_Button *)0;

static void cb_btnOlivia_8bit(Fl_Check_Button* o, void*) {
  progdefaults.olivia8bit = o->value();
progdefaults.changed = true;
}

Fl_Group *tabPSK=(Fl_Group *)0;

Fl_Counter *cntSearchRange=(Fl_Counter *)0;

static void cb_cntSearchRange(Fl_Counter* o, void*) {
  progdefaults.SearchRange = (int)o->value();
wf->redraw_marker();
progdefaults.changed = true;
}

Fl_Counter *cntACQsn=(Fl_Counter *)0;

static void cb_cntACQsn(Fl_Counter* o, void*) {
  progdefaults.ACQsn = (int)o->value();
progdefaults.changed = true;
}

static void cb_Dim(Fl_Check_Button* o, void*) {
  progdefaults.StatusDim = o->value();
progdefaults.changed = true;
}

static void cb_Seconds(Fl_Counter* o, void*) {
  progdefaults.StatusTimeout = (int)(o->value());
progdefaults.changed = true;
}

Fl_Check_Button *btnPSKmailSweetSpot=(Fl_Check_Button *)0;

static void cb_btnPSKmailSweetSpot(Fl_Check_Button* o, void*) {
  progdefaults.PSKmailSweetSpot = o->value();
progdefaults.changed = true;
}

Fl_Counter *cntServerOffset=(Fl_Counter *)0;

static void cb_cntServerOffset(Fl_Counter* o, void*) {
  progdefaults.ServerOffset = (int)o->value();
wf->redraw_marker();
progdefaults.changed = true;
}

Fl_Check_Button *btnMarquee=(Fl_Check_Button *)0;

static void cb_btnMarquee(Fl_Check_Button* o, void*) {
  progdefaults.VIEWERmarquee = o->value();
progdefaults.changed = true;
initViewer();
}

Fl_Check_Button *btnShowFrequencies=(Fl_Check_Button *)0;

static void cb_btnShowFrequencies(Fl_Check_Button* o, void*) {
  progdefaults.VIEWERshowfreq = o->value();
progdefaults.changed = true;
initViewer();
}

Fl_Spinner *cntChannels=(Fl_Spinner *)0;

static void cb_cntChannels(Fl_Spinner* o, void*) {
  progdefaults.VIEWERchannels = (int)(o->value());
initViewer();
}

Fl_Spinner *cntStartFrequency=(Fl_Spinner *)0;

static void cb_cntStartFrequency(Fl_Spinner* o, void*) {
  progdefaults.VIEWERstart = (int)(o->value());
progdefaults.changed = true;
initViewer();
}

Fl_Spinner *cntTimeout=(Fl_Spinner *)0;

static void cb_cntTimeout(Fl_Spinner* o, void*) {
  progdefaults.VIEWERtimeout = (int)(o->value());
progdefaults.changed = true;
}

Fl_Group *tabRTTY=(Fl_Group *)0;

Fl_Choice *selShift=(Fl_Choice *)0;

static void cb_selShift(Fl_Choice* o, void*) {
  progdefaults.rtty_shift = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Choice *selBaud=(Fl_Choice *)0;

static void cb_selBaud(Fl_Choice* o, void*) {
  progdefaults.rtty_baud = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Choice *selBits=(Fl_Choice *)0;

static void cb_selBits(Fl_Choice* o, void*) {
  progdefaults.rtty_bits = o->value();
selParity->do_callback();
}

Fl_Choice *selParity=(Fl_Choice *)0;

static void cb_selParity(Fl_Choice* o, void*) {
  if (progdefaults.rtty_bits == 0)
  o->value(progdefaults.rtty_parity = RTTY_PARITY_NONE);
else
  progdefaults.rtty_parity = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Choice *selStopBits=(Fl_Choice *)0;

static void cb_selStopBits(Fl_Choice* o, void*) {
  progdefaults.rtty_stop = o->value();
resetRTTY();
progdefaults.changed = true;
}

Fl_Check_Button *chkPseudoFSK=(Fl_Check_Button *)0;

static void cb_chkPseudoFSK(Fl_Check_Button* o, void*) {
  progdefaults.PseudoFSK = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCRCRLF=(Fl_Check_Button *)0;

static void cb_btnCRCRLF(Fl_Check_Button* o, void*) {
  progdefaults.rtty_crcrlf = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnAUTOCRLF=(Fl_Check_Button *)0;

static void cb_btnAUTOCRLF(Fl_Check_Button* o, void*) {
  progdefaults.rtty_autocrlf = o->value();
progdefaults.changed = true;
}

Fl_Counter *cntrAUTOCRLF=(Fl_Counter *)0;

static void cb_cntrAUTOCRLF(Fl_Counter* o, void*) {
  progdefaults.rtty_autocount = (int)o->value();
progdefaults.changed = true;
}

static void cb_btnRTTYafc(Fl_Round_Button*, void*) {
  progdefaults.rtty_afcspeed=0;
progdefaults.changed = true;
}

static void cb_btnRTTYafc1(Fl_Round_Button*, void*) {
  progdefaults.rtty_afcspeed=1;
progdefaults.changed = true;
}

Fl_Round_Button *btnRTTYafc[3]={(Fl_Round_Button *)0};

static void cb_btnRTTYafc2(Fl_Round_Button*, void*) {
  progdefaults.rtty_afcspeed=2;
progdefaults.changed = true;
}

Fl_Check_Button *btnPreferXhairScope=(Fl_Check_Button *)0;

static void cb_btnPreferXhairScope(Fl_Check_Button* o, void*) {
  progdefaults.PreferXhairScope=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkXagc=(Fl_Check_Button *)0;

static void cb_chkXagc(Fl_Check_Button* o, void*) {
  progdefaults.Xagc=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkUOSrx=(Fl_Check_Button *)0;

static void cb_chkUOSrx(Fl_Check_Button* o, void*) {
  progdefaults.UOSrx=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *chkUOStx=(Fl_Check_Button *)0;

static void cb_chkUOStx(Fl_Check_Button* o, void*) {
  progdefaults.UOStx=o->value();
progdefaults.changed = true;
}

Fl_Group *tabTHOR=(Fl_Group *)0;

Fl_Input *txtTHORSecondary=(Fl_Input *)0;

static void cb_txtTHORSecondary(Fl_Input* o, void*) {
  progdefaults.THORsecText = o->value();
progdefaults.changed = true;
}

Fl_Counter *valTHOR_BW=(Fl_Counter *)0;

static void cb_valTHOR_BW(Fl_Counter* o, void*) {
  progdefaults.THOR_BW = o->value();
resetTHOR();
progdefaults.changed = true;
}

Fl_Check_Button *valTHOR_FILTER=(Fl_Check_Button *)0;

static void cb_valTHOR_FILTER(Fl_Check_Button* o, void*) {
  progdefaults.THOR_FILTER = o->value();
resetTHOR();
progdefaults.changed = true;
}

Fl_Counter *valTHOR_PATHS=(Fl_Counter *)0;

static void cb_valTHOR_PATHS(Fl_Counter* o, void*) {
  progdefaults.THOR_PATHS = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *valTHOR_SOFT=(Fl_Check_Button *)0;

static void cb_valTHOR_SOFT(Fl_Check_Button* o, void*) {
  progdefaults.THOR_SOFT = o->value();
progdefaults.changed = true;
}

Fl_Value_Slider *valThorCWI=(Fl_Value_Slider *)0;

static void cb_valThorCWI(Fl_Value_Slider* o, void*) {
  progdefaults.ThorCWI = o->value();
progdefaults.changed = true;
}

Fl_Group *tabOperator=(Fl_Group *)0;

static void cb_tabOperator(Fl_Group*, void*) {
  progdefaults.changed = true;
}

Fl_Input *inpMyCallsign=(Fl_Input *)0;

static void cb_inpMyCallsign(Fl_Input* o, void*) {
  if (progdefaults.THORsecText.empty()) {
progdefaults.THORsecText = o->value();
progdefaults.THORsecText.append(" ");
txtTHORSecondary->value(progdefaults.THORsecText.c_str());
}
if (progdefaults.secText.empty()) {
progdefaults.secText = o->value();
progdefaults.secText.append(" ");
txtSecondary->value(progdefaults.secText.c_str());
}
progdefaults.myCall = o->value();
update_main_title();
progdefaults.changed = true;
}

Fl_Input *inpMyName=(Fl_Input *)0;

static void cb_inpMyName(Fl_Input* o, void*) {
  progdefaults.myName = o->value();
progdefaults.changed = true;
}

Fl_Input *inpMyQth=(Fl_Input *)0;

static void cb_inpMyQth(Fl_Input* o, void*) {
  progdefaults.myQth = o->value();
progdefaults.changed = true;
}

Fl_Input *inpMyLocator=(Fl_Input *)0;

static void cb_inpMyLocator(Fl_Input* o, void*) {
  progdefaults.myLocator = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnUseLeadingZeros=(Fl_Check_Button *)0;

static void cb_btnUseLeadingZeros(Fl_Check_Button* o, void*) {
  progdefaults.UseLeadingZeros = o->value();
progdefaults.changed = true;
}

Fl_Value_Input *nbrContestStart=(Fl_Value_Input *)0;

static void cb_nbrContestStart(Fl_Value_Input* o, void*) {
  progdefaults.ContestStart = (int)o->value();
progdefaults.changed = true;
}

Fl_Value_Input *nbrContestDigits=(Fl_Value_Input *)0;

static void cb_nbrContestDigits(Fl_Value_Input* o, void*) {
  progdefaults.ContestDigits = (int)o->value();
progdefaults.changed = true;
}

Fl_Input *inpMyAntenna=(Fl_Input *)0;

static void cb_inpMyAntenna(Fl_Input* o, void*) {
  progdefaults.myAntenna = o->value();
progdefaults.changed = true;
}

Fl_Group *tabQRZ=(Fl_Group *)0;

Fl_Round_Button *btnQRZnotavailable=(Fl_Round_Button *)0;

static void cb_btnQRZnotavailable(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZ_NONE;
progdefaults.changed = true;
}

Fl_Round_Button *btnQRZcdrom=(Fl_Round_Button *)0;

static void cb_btnQRZcdrom(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZ_CD;
progdefaults.changed = true;
}

Fl_Round_Button *btnQRZonline=(Fl_Round_Button *)0;

static void cb_btnQRZonline(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZ_NET_HTML;
progdefaults.changed = true;
}

Fl_Input *txtQRZpathname=(Fl_Input *)0;

static void cb_txtQRZpathname(Fl_Input* o, void*) {
  progdefaults.QRZpathname = o->value();
progdefaults.QRZchanged = true;
progdefaults.changed = true;
}

Fl_Input *inpQRZusername=(Fl_Input *)0;

static void cb_inpQRZusername(Fl_Input* o, void*) {
  progdefaults.QRZusername = o->value();
progdefaults.changed = true;
}

Fl_Input *inpQRZuserpassword=(Fl_Input *)0;

static void cb_inpQRZuserpassword(Fl_Input* o, void*) {
  progdefaults.QRZuserpassword = o->value();
progdefaults.changed = true;
}

Fl_Round_Button *btnQRZsub=(Fl_Round_Button *)0;

static void cb_btnQRZsub(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZ_NET_SUB;
progdefaults.changed = true;
}

Fl_Round_Button *btnHamcall=(Fl_Round_Button *)0;

static void cb_btnHamcall(Fl_Round_Button* o, void*) {
  set_qrz_buttons(o);
progdefaults.QRZ = QRZ_HAMCALL;
progdefaults.changed = true;
}

Fl_Button *btnQRZpasswordShow=(Fl_Button *)0;

static void cb_btnQRZpasswordShow(Fl_Button* o, void*) {
  progdefaults.SHOWPASSWORD ^= FL_SECRET_INPUT;
inpQRZuserpassword->type(progdefaults.SHOWPASSWORD);
inpQRZuserpassword->redraw();
o->label((progdefaults.SHOWPASSWORD & FL_SECRET_INPUT) ? "Show" : "Hide");
progdefaults.changed = true;
}

Fl_Group *tabRig=(Fl_Group *)0;

static void cb_btnPTT(Fl_Round_Button* o, void*) {
  btnPTT[1]->value(0);
btnPTT[2]->value(0);
btnPTT[3]->value(0);
btnPTT[4]->value(0);
o->value(1);
progdefaults.changed = true;
}

Fl_Round_Button *btnPTT[5]={(Fl_Round_Button *)0};

static void cb_btnPTT1(Fl_Round_Button* o, void*) {
  if (o->value() == 1) {
  btnPTT[0]->value(0);
  btnPTT[1]->value(0);
  btnPTT[2]->value(0);
  btnPTT[3]->value(0);
  btnRigCatRTSptt->value(0);
  btnRigCatDTRptt->value(0);
}
btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnRTSptt=(Fl_Round_Button *)0;

static void cb_btnRTSptt(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnDTRptt=(Fl_Round_Button *)0;

static void cb_btnDTRptt(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnRTSplusV=(Fl_Round_Button *)0;

static void cb_btnRTSplusV(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnDTRplusV=(Fl_Round_Button *)0;

static void cb_btnDTRplusV(Fl_Round_Button*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Input_Choice *inpTTYdev=(Fl_Input_Choice *)0;

static void cb_inpTTYdev(Fl_Input_Choice*, void*) {
  btnInitHWPTT->labelcolor(FL_RED);
btnInitHWPTT->redraw();
progdefaults.changed = true;
}

Fl_Button *btnInitHWPTT=(Fl_Button *)0;

static void cb_btnInitHWPTT(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Check_Button *chkUSERIGCAT=(Fl_Check_Button *)0;

static void cb_chkUSERIGCAT(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
  btnPTT[1]->value(0);
  btnPTT[2]->value(0);
  chkUSEHAMLIB->value(0);
  chkUSEMEMMAP->value(0);
  chkUSEXMLRPC->value(0);
  btnPTT[1]->value(0);
  btnPTT[1]->deactivate();
  btnPTT[2]->value(0);
  btnPTT[2]->deactivate();
  btnPTT[3]->activate();
  progdefaults.chkUSEMEMMAPis = false;
  progdefaults.chkUSEHAMLIBis = false;
  progdefaults.chkUSERIGCATis = true;
  progdefaults.chkUSEXMLRPCis = false;
  } else {
  if (btnPTT[3]->value() == 1)
  	btnPTT[0]->value(1);
  btnPTT[3]->value(0);
  btnPTT[3]->deactivate();
  progdefaults.chkUSERIGCATis = false;
  }
for (int i = 0; i < 4; btnPTT[i++]->redraw());
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

static void cb_btnPTT2(Fl_Round_Button* o, void*) {
  if (o->value()== 1) {
  btnRigCatRTSptt->value(0);
  btnRigCatDTRptt->value(0);
  btnPTT[0]->value(0);
  btnPTT[1]->value(0);
  btnPTT[2]->value(0);
  btnPTT[4]->value(0);
  }
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Output *txtXmlRigFilename=(Fl_Output *)0;

Fl_Button *btnSelectRigXmlFile=(Fl_Button *)0;

static void cb_btnSelectRigXmlFile(Fl_Button*, void*) {
  btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
selectRigXmlFilename();
}

Fl_Input_Choice *inpXmlRigDevice=(Fl_Input_Choice *)0;

static void cb_inpXmlRigDevice(Fl_Input_Choice* o, void*) {
  progdefaults.XmlRigDevice = o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Choice *mnuXmlRigBaudrate=(Fl_Choice *)0;

static void cb_mnuXmlRigBaudrate(Fl_Choice* o, void*) {
  progdefaults.XmlRigBaudrate = o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnRigCatRTSptt=(Fl_Round_Button *)0;

static void cb_btnRigCatRTSptt(Fl_Round_Button* o, void*) {
  if (o->value() == 1) {
  btnRigCatDTRptt->value(0);
  btnPTT[0]->value(0);
  btnPTT[1]->value(0);
  btnPTT[2]->value(0);
  btnPTT[3]->value(0);
  btnPTT[4]->value(0);
  progdefaults.RigCatRTSptt = true;
} else
  progdefaults.RigCatRTSptt = false;
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Round_Button *btnRigCatDTRptt=(Fl_Round_Button *)0;

static void cb_btnRigCatDTRptt(Fl_Round_Button* o, void*) {
  if (o->value() == 1) {
  btnRigCatRTSptt->value(0);
  btnPTT[0]->value(0);
  btnPTT[1]->value(0);
  btnPTT[2]->value(0);
  btnPTT[3]->value(0);
  btnPTT[4]->value(0);
  progdefaults.RigCatDTRptt = true;
} else
  progdefaults.RigCatDTRptt = false;
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *btnRigCatRTSplus=(Fl_Check_Button *)0;

static void cb_btnRigCatRTSplus(Fl_Check_Button* o, void*) {
  progdefaults.RigCatRTSplus = o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *btnRigCatDTRplus=(Fl_Check_Button *)0;

static void cb_btnRigCatDTRplus(Fl_Check_Button* o, void*) {
  progdefaults.RigCatDTRplus = o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Counter *cntRigCatRetries=(Fl_Counter *)0;

static void cb_cntRigCatRetries(Fl_Counter* o, void*) {
  progdefaults.RigCatRetries = (int)o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Counter *cntRigCatTimeout=(Fl_Counter *)0;

static void cb_cntRigCatTimeout(Fl_Counter* o, void*) {
  progdefaults.RigCatTimeout = (int)o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Counter *cntRigCatWait=(Fl_Counter *)0;

static void cb_cntRigCatWait(Fl_Counter* o, void*) {
  progdefaults.RigCatWait = (int)o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Button *btnInitRIGCAT=(Fl_Button *)0;

static void cb_btnInitRIGCAT(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Check_Button *chkRigCatRTSCTSflow=(Fl_Check_Button *)0;

static void cb_chkRigCatRTSCTSflow(Fl_Check_Button* o, void*) {
  progdefaults.RigCatRTSCTSflow = o->value();
btnInitRIGCAT->labelcolor(FL_RED);
btnInitRIGCAT->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *chkUSEHAMLIB=(Fl_Check_Button *)0;

static void cb_chkUSEHAMLIB(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
  btnPTT[3]->value(0);
  btnPTT[2]->value(0);
  chkUSEMEMMAP->value(0);
  chkUSERIGCAT->value(0);
  chkUSEXMLRPC->value(0);
  btnPTT[3]->value(0);
  btnPTT[3]->deactivate();
  btnPTT[2]->value(0);
  btnPTT[2]->deactivate();
  btnPTT[1]->activate();
  progdefaults.chkUSEMEMMAPis = false;
  progdefaults.chkUSEHAMLIBis = true;
  progdefaults.chkUSERIGCATis = false;
  progdefaults.chkUSEXMLRPCis = false;
  } else {
  if (btnPTT[1]->value()==1)
 	btnPTT[0]->value(1);
  btnPTT[1]->value(0);
  btnPTT[1]->deactivate();
  progdefaults.chkUSEHAMLIBis = false;
  }
for (int i = 0; i < 4; btnPTT[i++]->redraw());
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

static void cb_btnPTT3(Fl_Round_Button* o, void*) {
  if (o->value() == 1) {
  btnPTT[0]->value(0);
  btnPTT[2]->value(0);
  btnPTT[3]->value(0);
  btnPTT[4]->value(0);
  btnRigCatRTSptt->value(0);
  btnRigCatDTRptt->value(0);
}
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_ComboBox *cboHamlibRig=(Fl_ComboBox *)0;

static void cb_cboHamlibRig(Fl_ComboBox*, void*) {
  btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Input_Choice *inpRIGdev=(Fl_Input_Choice *)0;

static void cb_inpRIGdev(Fl_Input_Choice* o, void*) {
  progdefaults.HamRigDevice = o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Choice *mnuBaudRate=(Fl_Choice *)0;

static void cb_mnuBaudRate(Fl_Choice* o, void*) {
  progdefaults.HamRigBaudrate = o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Button *btnInitHAMLIB=(Fl_Button *)0;

static void cb_btnInitHAMLIB(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Counter *cntHamlibtRetries=(Fl_Counter *)0;

static void cb_cntHamlibtRetries(Fl_Counter* o, void*) {
  progdefaults.HamlibRetries = (int)o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Counter *cntHamlibTimeout=(Fl_Counter *)0;

static void cb_cntHamlibTimeout(Fl_Counter* o, void*) {
  progdefaults.HamlibTimeout = (int)o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Counter *cntHamlibWait=(Fl_Counter *)0;

static void cb_cntHamlibWait(Fl_Counter* o, void*) {
  progdefaults.HamlibWait = (int)o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *btnHamlibDTRplus=(Fl_Check_Button *)0;

static void cb_btnHamlibDTRplus(Fl_Check_Button* o, void*) {
  progdefaults.HamlibDTRplus = o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *chkHamlibRTSplus=(Fl_Check_Button *)0;

static void cb_chkHamlibRTSplus(Fl_Check_Button* o, void*) {
  progdefaults.HamlibRTSplus = o->value();
if (o->value() == 1) {
chkHamlibRTSCTSflow->value(0);
progdefaults.HamlibRTSCTSflow = false;
}
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *chkHamlibRTSCTSflow=(Fl_Check_Button *)0;

static void cb_chkHamlibRTSCTSflow(Fl_Check_Button* o, void*) {
  progdefaults.HamlibRTSCTSflow = o->value();
if (o->value() == 1) {
  chkHamlibRTSplus->value(0);
  chkHamlibXONXOFFflow->value(0);
  progdefaults.HamlibXONXOFFflow = false;
}
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *chkHamlibXONXOFFflow=(Fl_Check_Button *)0;

static void cb_chkHamlibXONXOFFflow(Fl_Check_Button* o, void*) {
  progdefaults.HamlibXONXOFFflow = o->value();
if (o->value() == 1) {
  chkHamlibRTSCTSflow->value(0);
  progdefaults.HamlibRTSCTSflow = false;
}
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Input *inpHamlibConfig=(Fl_Input *)0;

static void cb_inpHamlibConfig(Fl_Input* o, void*) {
  progdefaults.HamConfig = o->value();
btnInitHAMLIB->labelcolor(FL_RED);
btnInitHAMLIB->redraw();
progdefaults.changed = true;
}

Fl_Check_Button *chkUSEMEMMAP=(Fl_Check_Button *)0;

static void cb_chkUSEMEMMAP(Fl_Check_Button* o, void*) {
  if(o->value() == 1){
  chkUSEHAMLIB->value(0);
  chkUSERIGCAT->value(0);
  chkUSEXMLRPC->value(0);
  btnPTT[3]->value(0);
  btnPTT[3]->deactivate();
  btnPTT[1]->value(0);
  btnPTT[1]->deactivate();
  btnPTT[2]->activate();
  progdefaults.chkUSEMEMMAPis = true;
  progdefaults.chkUSEHAMLIBis = false;
  progdefaults.chkUSERIGCATis = false;
  progdefaults.chkUSEXMLRPCis = false;
  } else {
  if (btnPTT[2]->value()==1)
  	btnPTT[0]->value(1);
  btnPTT[2]->value(0);
  btnPTT[2]->deactivate();
  progdefaults.chkUSEMEMMAPis = false;
  }
for (int i = 0; i < 4; btnPTT[i++]->redraw());  
btnInitMEMMAP->labelcolor(FL_RED);
btnInitMEMMAP->redraw();
progdefaults.changed = true;
}

static void cb_btnPTT4(Fl_Round_Button* o, void*) {
  if (o->value() == 1) {
  btnPTT[0]->value(0);
  btnPTT[1]->value(0);
  btnPTT[3]->value(0);
  btnPTT[4]->value(0);
  btnRigCatRTSptt->value(0);
  btnRigCatDTRptt->value(0);
}
btnInitMEMMAP->labelcolor(FL_RED);
btnInitMEMMAP->redraw();
progdefaults.changed = true;
}

Fl_Button *btnInitMEMMAP=(Fl_Button *)0;

static void cb_btnInitMEMMAP(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Check_Button *chkUSEXMLRPC=(Fl_Check_Button *)0;

static void cb_chkUSEXMLRPC(Fl_Check_Button* o, void*) {
  if(o->value() == 1){
  chkUSEHAMLIB->value(0);
  chkUSERIGCAT->value(0);
  chkUSEMEMMAP->value(0);
  btnPTT[3]->value(0);
  btnPTT[3]->deactivate();
  btnPTT[1]->value(0);
  btnPTT[1]->deactivate();
  btnPTT[2]->activate();
  progdefaults.chkUSEMEMMAPis = false;
  progdefaults.chkUSEHAMLIBis = false;
  progdefaults.chkUSERIGCATis = false;
  progdefaults.chkUSEXMLRPCis = true;
  } else {
  progdefaults.chkUSEXMLRPCis = false;
  }
for (int i = 0; i < 4; btnPTT[i++]->redraw());  
btnInitXMLRPC->labelcolor(FL_RED);
btnInitXMLRPC->redraw();
progdefaults.changed = true;
}

Fl_Button *btnInitXMLRPC=(Fl_Button *)0;

static void cb_btnInitXMLRPC(Fl_Button* o, void*) {
  progdefaults.initInterface();
o->labelcolor(FL_FOREGROUND_COLOR);
progdefaults.changed = true;
}

Fl_Group *tabSoundCard=(Fl_Group *)0;

Fl_Tabs *tabsSoundCard=(Fl_Tabs *)0;

Fl_Group *tabAudio=(Fl_Group *)0;

Fl_Group *AudioOSS=(Fl_Group *)0;

static void cb_btnAudioIO(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_OSS);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Input_Choice *menuOSSDev=(Fl_Input_Choice *)0;

static void cb_menuOSSDev(Fl_Input_Choice* o, void*) {
  scDevice[0] = scDevice[1] = progdefaults.OSSdevice = o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Group *AudioPort=(Fl_Group *)0;

static void cb_btnAudioIO1(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_PORT);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Choice *menuPortInDev=(Fl_Choice *)0;

static void cb_menuPortInDev(Fl_Choice* o, void*) {
  scDevice[0] = progdefaults.PortInDevice = o->text();
progdefaults.PortInIndex = reinterpret_cast<intptr_t>(o->mvalue()->user_data());
resetSoundCard();
progdefaults.changed = true;
}

Fl_Choice *menuPortOutDev=(Fl_Choice *)0;

static void cb_menuPortOutDev(Fl_Choice* o, void*) {
  scDevice[1] = progdefaults.PortOutDevice = o->text();
progdefaults.PortOutIndex = reinterpret_cast<intptr_t>(o->mvalue()->user_data());
resetSoundCard();
progdefaults.changed = true;
}

Fl_Group *AudioPulse=(Fl_Group *)0;

static void cb_btnAudioIO2(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_PULSE);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Input *inpPulseServer=(Fl_Input *)0;

static void cb_inpPulseServer(Fl_Input* o, void*) {
  scDevice[0] = scDevice[1] = progdefaults.PulseServer = o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Group *AudioNull=(Fl_Group *)0;

Fl_Round_Button *btnAudioIO[4]={(Fl_Round_Button *)0};

static void cb_btnAudioIO3(Fl_Round_Button*, void*) {
  sound_update(SND_IDX_NULL);
progdefaults.changed = true;
resetSoundCard();
}

Fl_Group *tabAudioOpt=(Fl_Group *)0;

Fl_Spinner *cntRxRateCorr=(Fl_Spinner *)0;

static void cb_cntRxRateCorr(Fl_Spinner* o, void*) {
  progdefaults.RX_corr = (int)o->value();
progdefaults.changed = true;
}

Fl_Spinner *cntTxRateCorr=(Fl_Spinner *)0;

static void cb_cntTxRateCorr(Fl_Spinner* o, void*) {
  progdefaults.TX_corr = (int)o->value();
progdefaults.changed = true;
}

Fl_Spinner *cntTxOffset=(Fl_Spinner *)0;

static void cb_cntTxOffset(Fl_Spinner* o, void*) {
  progdefaults.TxOffset = (int)o->value();
progdefaults.changed = true;
}

Fl_Group *AudioSampleRate=(Fl_Group *)0;

Fl_Choice *menuOutSampleRate=(Fl_Choice *)0;

static void cb_menuOutSampleRate(Fl_Choice* o, void*) {
  progdefaults.out_sample_rate = o->value() > 1 ? strtol(o->mvalue()->text, 0, 10) : o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Choice *menuInSampleRate=(Fl_Choice *)0;

static void cb_menuInSampleRate(Fl_Choice* o, void*) {
  progdefaults.in_sample_rate = o->value() > 1 ? strtol(o->mvalue()->text, 0, 10) : o->value();
resetSoundCard();
progdefaults.changed = true;
}

Fl_Choice *menuSampleConverter=(Fl_Choice *)0;

static void cb_menuSampleConverter(Fl_Choice* o, void*) {
  progdefaults.sample_converter = o->value();
resetSoundCard();
progdefaults.changed = true;
o->tooltip(src_get_description(o->value()));
}

Fl_Group *tabMixer=(Fl_Group *)0;

Fl_Light_Button *btnLineIn=(Fl_Light_Button *)0;

static void cb_btnLineIn(Fl_Light_Button* o, void*) {
  if (o->value() == 1) {
    btnMicIn->value(0);
    progdefaults.LineIn = true;
    progdefaults.MicIn = false;
    setMixerInput(1);
} else {
    setMixerInput(0);
    progdefaults.LineIn = false;
}
progdefaults.changed = true;
}

Fl_Light_Button *btnMicIn=(Fl_Light_Button *)0;

static void cb_btnMicIn(Fl_Light_Button* o, void*) {
  if (o->value() == 1) {
    btnLineIn->value(0);
    progdefaults.LineIn = false;
    progdefaults.MicIn = true;
    setMixerInput(2);
} else {
    setMixerInput(0);
    progdefaults.MicIn = false;
}
progdefaults.changed = true;
}

Fl_Value_Slider *valPCMvolume=(Fl_Value_Slider *)0;

static void cb_valPCMvolume(Fl_Value_Slider* o, void*) {
  setPCMvolume(o->value());
progdefaults.changed = true;
}

Fl_Input_Choice *menuMix=(Fl_Input_Choice *)0;

static void cb_menuMix(Fl_Input_Choice* o, void*) {
  progdefaults.MXdevice = o->value();
enableMixer(false);
enableMixer(true);
progdefaults.changed = true;
}

Fl_Check_Button *btnMixer=(Fl_Check_Button *)0;

static void cb_btnMixer(Fl_Check_Button* o, void*) {
  enableMixer(o->value());
progdefaults.changed = true;
}

Fl_Group *tabUI=(Fl_Group *)0;

Fl_Group *tabUserInterface=(Fl_Group *)0;

Fl_Check_Button *btnShowTooltips=(Fl_Check_Button *)0;

static void cb_btnShowTooltips(Fl_Check_Button* o, void*) {
  progdefaults.tooltips = o->value();
Fl_Tooltip::enable(progdefaults.tooltips);
progdefaults.changed = true;
}

Fl_Check_Button *chkMenuIcons=(Fl_Check_Button *)0;

static void cb_chkMenuIcons(Fl_Check_Button* o, void*) {
  progdefaults.menuicons = o->value();
toggle_icon_labels();
progdefaults.changed = true;
}

Fl_Choice *mnuScheme=(Fl_Choice *)0;

static void cb_mnuScheme(Fl_Choice* o, void*) {
  progdefaults.ui_scheme = o->text();
    Fl::scheme(progdefaults.ui_scheme.c_str());

    progdefaults.changed = true;
}

Fl_Check_Button *btnNagMe=(Fl_Check_Button *)0;

static void cb_btnNagMe(Fl_Check_Button* o, void*) {
  progdefaults.NagMe=o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnClearOnSave=(Fl_Check_Button *)0;

static void cb_btnClearOnSave(Fl_Check_Button* o, void*) {
  progdefaults.ClearOnSave=o->value();
progdefaults.changed = true;
}

Fl_Group *tabWfallRestart=(Fl_Group *)0;

Fl_Counter *cntrWfwidth=(Fl_Counter *)0;

static void cb_cntrWfwidth(Fl_Counter* o, void*) {
  progdefaults.wfwidth = (int)(o->value());
progdefaults.changed = true;
}

Fl_Counter *cntrWfheight=(Fl_Counter *)0;

static void cb_cntrWfheight(Fl_Counter* o, void*) {
  progdefaults.wfheight = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDockedScope=(Fl_Check_Button *)0;

static void cb_btnDockedScope(Fl_Check_Button* o, void*) {
  progdefaults.docked_scope = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnDockedRigControl=(Fl_Check_Button *)0;

static void cb_btnDockedRigControl(Fl_Check_Button* o, void*) {
  progdefaults.docked_rig_control = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnCheckButtons=(Fl_Check_Button *)0;

static void cb_btnCheckButtons(Fl_Check_Button* o, void*) {
  progdefaults.useCheckButtons = o->value();
progdefaults.changed = true;
}

Fl_Group *tabWaterfall=(Fl_Group *)0;

colorbox *WF_Palette=(colorbox *)0;

static void cb_WF_Palette(colorbox*, void*) {
  progdefaults.changed = true;
}

static void cb_btnColor(Fl_Button*, void*) {
  selectColor(0);
progdefaults.changed = true;
}

static void cb_btnColor1(Fl_Button*, void*) {
  selectColor(1);
progdefaults.changed = true;
}

static void cb_btnColor2(Fl_Button*, void*) {
  selectColor(2);
progdefaults.changed = true;
}

static void cb_btnColor3(Fl_Button*, void*) {
  selectColor(3);
progdefaults.changed = true;
}

static void cb_btnColor4(Fl_Button*, void*) {
  selectColor(4);
progdefaults.changed = true;
}

static void cb_btnColor5(Fl_Button*, void*) {
  selectColor(5);
progdefaults.changed = true;
}

static void cb_btnColor6(Fl_Button*, void*) {
  selectColor(6);
progdefaults.changed = true;
}

static void cb_btnColor7(Fl_Button*, void*) {
  selectColor(7);
progdefaults.changed = true;
}

Fl_Button *btnColor[9]={(Fl_Button *)0};

static void cb_btnColor8(Fl_Button*, void*) {
  selectColor(8);
progdefaults.changed = true;
}

Fl_Button *btnLoadPalette=(Fl_Button *)0;

static void cb_btnLoadPalette(Fl_Button*, void*) {
  loadPalette();
progdefaults.changed = true;
}

Fl_Button *btnSavePalette=(Fl_Button *)0;

static void cb_btnSavePalette(Fl_Button*, void*) {
  savePalette();
}

Fl_Counter *cntLowFreqCutoff=(Fl_Counter *)0;

static void cb_cntLowFreqCutoff(Fl_Counter* o, void*) {
  progdefaults.LowFreqCutoff=(int)(o->value());
progdefaults.changed = true;
}

Fl_Check_Button *btnWFaveraging=(Fl_Check_Button *)0;

static void cb_btnWFaveraging(Fl_Check_Button* o, void*) {
  progdefaults.WFaveraging = o->value();
progdefaults.changed = true;
}

Fl_Button *btnWaterfallFont=(Fl_Button *)0;

static void cb_btnWaterfallFont(Fl_Button*, void*) {
  static Font_Browser *b = (Font_Browser *)0;
if (!b) {
b = new Font_Browser;
b->fontNumber(progdefaults.WaterfallFontnbr);
b->fontSize(progdefaults.WaterfallFontsize);
}
b->callback((Fl_Callback*)cbWaterfallFontBrowser, (void*)(b));
b->show();
}

Fl_Check_Button *btnBlackman=(Fl_Check_Button *)0;

static void cb_btnBlackman(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
progdefaults.wfPreFilter=1;
btnHamming->value(0);
btnHanning->value(0);
btnTriangular->value(0);
} else o->value(1);
progdefaults.changed = true;
}

Fl_Check_Button *btnHamming=(Fl_Check_Button *)0;

static void cb_btnHamming(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
progdefaults.wfPreFilter=2;
btnBlackman->value(0);
btnHanning->value(0);
btnTriangular->value(0);
} else o->value(1);
progdefaults.changed = true;
}

Fl_Check_Button *btnHanning=(Fl_Check_Button *)0;

static void cb_btnHanning(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
progdefaults.wfPreFilter=3;
btnHamming->value(0);
btnBlackman->value(0);
btnTriangular->value(0);
} else o->value(1);
progdefaults.changed = true;
}

Fl_Check_Button *btnTriangular=(Fl_Check_Button *)0;

static void cb_btnTriangular(Fl_Check_Button* o, void*) {
  if (o->value() == 1) {
progdefaults.wfPreFilter=4;
btnHamming->value(0);
btnHanning->value(0);
btnBlackman->value(0);
} else o->value(1);
progdefaults.changed = true;
}

Fl_Counter *valLatency=(Fl_Counter *)0;

static void cb_valLatency(Fl_Counter* o, void*) {
  progdefaults.latency = (int)o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnUseCursorLines=(Fl_Check_Button *)0;

static void cb_btnUseCursorLines(Fl_Check_Button* o, void*) {
  progdefaults.UseCursorLines = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnUseBWTracks=(Fl_Check_Button *)0;

static void cb_btnUseBWTracks(Fl_Check_Button* o, void*) {
  progdefaults.UseBWTracks = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnUseCursorCenterLine=(Fl_Check_Button *)0;

static void cb_btnUseCursorCenterLine(Fl_Check_Button* o, void*) {
  progdefaults.UseCursorCenterLine = o->value();
progdefaults.changed = true;
}

Fl_Button *btnCursorBWcolor=(Fl_Button *)0;

static void cb_btnCursorBWcolor(Fl_Button* o, void*) {
  if (fl_color_chooser("Cursor BW Lines",
  progdefaults.cursorLineRGBI.R, 
  progdefaults.cursorLineRGBI.G, 
  progdefaults.cursorLineRGBI.B) ) {
o->color(fl_rgb_color(progdefaults.cursorLineRGBI.R,progdefaults.cursorLineRGBI.G,progdefaults.cursorLineRGBI.B));
o->redraw();
progdefaults.changed = true;
};
}

Fl_Button *btnCursorCenterLineColor=(Fl_Button *)0;

static void cb_btnCursorCenterLineColor(Fl_Button* o, void*) {
  if (fl_color_chooser("Cursor Center Line",
  progdefaults.cursorCenterRGBI.R, 
  progdefaults.cursorCenterRGBI.G, 
  progdefaults.cursorCenterRGBI.B) ) {
o->color(fl_rgb_color(progdefaults.cursorCenterRGBI.R,progdefaults.cursorCenterRGBI.G,progdefaults.cursorCenterRGBI.B));
o->redraw();
progdefaults.changed = true;
};
}

Fl_Button *btnBwTracksColor=(Fl_Button *)0;

static void cb_btnBwTracksColor(Fl_Button* o, void*) {
  if (fl_color_chooser("Track Lines",
  progdefaults.bwTrackRGBI.R, 
  progdefaults.bwTrackRGBI.G, 
  progdefaults.bwTrackRGBI.B) ) {
o->color(fl_rgb_color(progdefaults.bwTrackRGBI.R,progdefaults.bwTrackRGBI.G,progdefaults.bwTrackRGBI.B));
o->redraw();
progdefaults.changed = true;
};
}

Fl_Check_Button *chkShowAudioScale=(Fl_Check_Button *)0;

static void cb_chkShowAudioScale(Fl_Check_Button* o, void*) {
  progdefaults.wf_audioscale = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnViewXmtSignal=(Fl_Check_Button *)0;

static void cb_btnViewXmtSignal(Fl_Check_Button* o, void*) {
  progdefaults.viewXmtSignal=o->value();
progdefaults.changed = true;
}

Fl_Value_Slider *valTxMonitorLevel=(Fl_Value_Slider *)0;

static void cb_valTxMonitorLevel(Fl_Value_Slider* o, void*) {
  progdefaults.TxMonitorLevel = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnWaterfallHistoryDefault=(Fl_Check_Button *)0;

static void cb_btnWaterfallHistoryDefault(Fl_Check_Button* o, void*) {
  progdefaults.WaterfallHistoryDefault = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnWaterfallQSY=(Fl_Check_Button *)0;

static void cb_btnWaterfallQSY(Fl_Check_Button* o, void*) {
  progdefaults.WaterfallQSY = o->value();
progdefaults.changed = true;
}

Fl_Input *inpWaterfallClickText=(Fl_Input *)0;

static void cb_inpWaterfallClickText(Fl_Input* o, void*) {
  progdefaults.WaterfallClickText = o->value();
progdefaults.changed = true;
}

Fl_Check_Button *btnWaterfallClickInsert=(Fl_Check_Button *)0;

static void cb_btnWaterfallClickInsert(Fl_Check_Button* o, void*) {
  progdefaults.WaterfallClickInsert = o->value();
if (progdefaults.WaterfallClickInsert)
    inpWaterfallClickText->activate();
else
    inpWaterfallClickText->deactivate();
progdefaults.changed = true;
}

Fl_Choice *mnuWaterfallWheelAction=(Fl_Choice *)0;

static void cb_mnuWaterfallWheelAction(Fl_Choice* o, void*) {
  progdefaults.WaterfallWheelAction = o->value();
progdefaults.changed = true;
}

Fl_Button *btnSaveConfig=(Fl_Button *)0;

static void cb_btnSaveConfig(Fl_Button*, void*) {
  progdefaults.saveDefaults();
}

Fl_Return_Button *btnCloseConfig=(Fl_Return_Button *)0;

static void cb_btnCloseConfig(Fl_Return_Button*, void*) {
  closeDialog();
}

Fl_Double_Window* ConfigureDialog() {
  Fl_Double_Window* w;
  static const char szShifts[]  = "23|85|160|170|182|200|240|350|425|850";
static const char szBauds[]  = "45|45.45|50|56|75|100|110|150|200|300";
static const char szSelBits[] = "5 (baudot)|7 (ascii)|8 (ascii)";
static const char szParity[]  = "none|even|odd|zero|one";
static const char szStopBits[] = "1|1.5|2";
static const char szOliviaTones[] = "2|4|8|16|32|64|128|256";
static const char szOliviaBandwidth[] = "125|250|500|1000|2000";
static const char szBaudRates[] = "300|600|1200|2400|4800|9600|19200|38400|57600|115200|230400|460800";
  { Fl_Double_Window* o = new Fl_Double_Window(400, 255, "fldigi - config");
    w = o;
    o->tooltip("Leading/Trailing Risetimes (msec)");
    o->color(FL_DARK2);
    o->selection_color((Fl_Color)51);
    o->labelsize(18);
    o->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
    { tabsConfigure = new Fl_Tabs(0, 0, 405, 225);
      tabsConfigure->color(FL_DARK1);
      tabsConfigure->selection_color((Fl_Color)9);
      { tabID = new Fl_Group(0, 25, 400, 195, "Id\'s");
        tabID->color((Fl_Color)51);
        tabID->selection_color((Fl_Color)51);
        tabID->hide();
        { Fl_Group* o = new Fl_Group(5, 40, 390, 77, "Video Preamble ID");
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { btnsendid = new Fl_Check_Button(11, 57, 115, 20, "Xmt Mode ID");
            btnsendid->down_box(FL_DOWN_BOX);
            btnsendid->callback((Fl_Callback*)cb_btnsendid);
          } // Fl_Check_Button* btnsendid
          { Fl_Check_Button* o = btnsendvideotext = new Fl_Check_Button(11, 89, 130, 20, "Xmt Video Text");
            btnsendvideotext->down_box(FL_DOWN_BOX);
            btnsendvideotext->callback((Fl_Callback*)cb_btnsendvideotext);
            o->value(progdefaults.sendtextid);
          } // Fl_Check_Button* btnsendvideotext
          { Fl_Input* o = valVideotext = new Fl_Input(159, 89, 120, 20, "Video Text:");
            valVideotext->tooltip("Limit to a few characters as in CQEM or IOTA etc.");
            valVideotext->callback((Fl_Callback*)cb_valVideotext);
            valVideotext->align(FL_ALIGN_TOP_LEFT);
            o->value(progdefaults.strTextid.c_str());
          } // Fl_Input* valVideotext
          { Fl_Value_Slider* o = sldrVideowidth = new Fl_Value_Slider(290, 89, 95, 20, "Video Width:");
            sldrVideowidth->tooltip("Set the # of chars per row");
            sldrVideowidth->type(1);
            sldrVideowidth->color((Fl_Color)26);
            sldrVideowidth->minimum(1);
            sldrVideowidth->maximum(4);
            sldrVideowidth->step(1);
            sldrVideowidth->value(1);
            sldrVideowidth->textsize(14);
            sldrVideowidth->callback((Fl_Callback*)cb_sldrVideowidth);
            sldrVideowidth->align(FL_ALIGN_TOP);
            o->value(progdefaults.videowidth);
            if (progdefaults.ID_SMALL) o->deactivate();
          } // Fl_Value_Slider* sldrVideowidth
          { Fl_Check_Button* o = chkID_SMALL = new Fl_Check_Button(290, 49, 100, 20, "small font");
            chkID_SMALL->down_box(FL_DOWN_BOX);
            chkID_SMALL->value(1);
            chkID_SMALL->callback((Fl_Callback*)cb_chkID_SMALL);
            o->value(progdefaults.ID_SMALL);
          } // Fl_Check_Button* chkID_SMALL
          o->end();
        } // Fl_Group* o
        { sld = new Fl_Group(5, 117, 390, 54, "CW Postamble ID");
          sld->box(FL_ENGRAVED_FRAME);
          sld->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Check_Button* o = btnCWID = new Fl_Check_Button(13, 142, 98, 15, "Xmt CWID");
            btnCWID->tooltip("send CW callsign at end of transmission");
            btnCWID->down_box(FL_DOWN_BOX);
            btnCWID->callback((Fl_Callback*)cb_btnCWID);
            o->value(progdefaults.CWid);
          } // Fl_Check_Button* btnCWID
          { Fl_Value_Slider* o = sldrCWIDwpm = new Fl_Value_Slider(150, 139, 233, 20, "CWID wpm:");
            sldrCWIDwpm->tooltip("speed in WPM");
            sldrCWIDwpm->type(1);
            sldrCWIDwpm->color((Fl_Color)26);
            sldrCWIDwpm->minimum(15);
            sldrCWIDwpm->maximum(40);
            sldrCWIDwpm->step(1);
            sldrCWIDwpm->value(18);
            sldrCWIDwpm->textsize(14);
            sldrCWIDwpm->callback((Fl_Callback*)cb_sldrCWIDwpm);
            sldrCWIDwpm->align(FL_ALIGN_TOP_LEFT);
            o->value(progdefaults.CWIDwpm);
          } // Fl_Value_Slider* sldrCWIDwpm
          sld->end();
        } // Fl_Group* sld
        { Fl_Group* o = new Fl_Group(5, 170, 390, 45, "Reed Solomon ID");
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Check_Button* o = chkTransmitRSid = new Fl_Check_Button(70, 190, 119, 20, "Transmit RSid");
            chkTransmitRSid->tooltip("Transmit Reed Solomon ID");
            chkTransmitRSid->down_box(FL_DOWN_BOX);
            chkTransmitRSid->callback((Fl_Callback*)cb_chkTransmitRSid);
            o->value(progdefaults.TransmitRSid);
          } // Fl_Check_Button* chkTransmitRSid
          { Fl_Check_Button* o = chkRSidWideSearch = new Fl_Check_Button(209, 192, 85, 15, "Wide Search Detector");
            chkRSidWideSearch->tooltip("Search over entire waterfall");
            chkRSidWideSearch->down_box(FL_DOWN_BOX);
            chkRSidWideSearch->callback((Fl_Callback*)cb_chkRSidWideSearch);
            o->value(progdefaults.rsidWideSearch);
          } // Fl_Check_Button* chkRSidWideSearch
          o->end();
        } // Fl_Group* o
        tabID->end();
      } // Fl_Group* tabID
      { tabMisc = new Fl_Group(0, 25, 405, 200, "Misc");
        tabMisc->color((Fl_Color)51);
        tabMisc->selection_color((Fl_Color)51);
        tabMisc->hide();
        { tabsMisc = new Fl_Tabs(0, 25, 405, 200);
          tabsMisc->selection_color((Fl_Color)10);
          { tabCPUspeed = new Fl_Group(0, 50, 400, 170, "CPU");
            tabCPUspeed->hide();
            { Fl_Group* o = new Fl_Group(5, 62, 390, 43);
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = chkSlowCpu = new Fl_Check_Button(110, 72, 89, 20, "Slow cpu");
                chkSlowCpu->tooltip("select for CPU < 700 MHz");
                chkSlowCpu->down_box(FL_DOWN_BOX);
                chkSlowCpu->callback((Fl_Callback*)cb_chkSlowCpu);
                o->value(progdefaults.slowcpu);
              } // Fl_Check_Button* chkSlowCpu
              o->end();
            } // Fl_Group* o
            tabCPUspeed->end();
          } // Fl_Group* tabCPUspeed
          { tabMacros = new Fl_Group(0, 50, 400, 170, "Macros");
            tabMacros->hide();
            { Fl_Group* o = new Fl_Group(5, 55, 390, 69);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnUseLastMacro = new Fl_Check_Button(30, 70, 274, 15, "load last used Macro file on startup");
                btnUseLastMacro->down_box(FL_DOWN_BOX);
                btnUseLastMacro->callback((Fl_Callback*)cb_btnUseLastMacro);
                o->value(progdefaults.UseLastMacro);
              } // Fl_Check_Button* btnUseLastMacro
              { Fl_Check_Button* o = btnDisplayMacroFilename = new Fl_Check_Button(30, 91, 274, 15, "display Macro Filename on startup");
                btnDisplayMacroFilename->tooltip("filename is written to the Rx text area");
                btnDisplayMacroFilename->down_box(FL_DOWN_BOX);
                btnDisplayMacroFilename->callback((Fl_Callback*)cb_btnDisplayMacroFilename);
                o->value(progdefaults.DisplayMacroFilename);
              } // Fl_Check_Button* btnDisplayMacroFilename
              o->end();
            } // Fl_Group* o
            tabMacros->end();
          } // Fl_Group* tabMacros
          { tabSweetSpot = new Fl_Group(0, 50, 400, 170, "Sweet Spot");
            tabSweetSpot->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 390, 75);
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Value_Input* o = valCWsweetspot = new Fl_Value_Input(50, 71, 65, 20, "CW");
                valCWsweetspot->minimum(200);
                valCWsweetspot->maximum(4000);
                valCWsweetspot->step(1);
                valCWsweetspot->value(1000);
                valCWsweetspot->callback((Fl_Callback*)cb_valCWsweetspot);
                o->value(progdefaults.CWsweetspot);
              } // Fl_Value_Input* valCWsweetspot
              { Fl_Value_Input* o = valRTTYsweetspot = new Fl_Value_Input(182, 71, 65, 20, "RTTY");
                valRTTYsweetspot->minimum(200);
                valRTTYsweetspot->maximum(4000);
                valRTTYsweetspot->step(1);
                valRTTYsweetspot->value(1000);
                valRTTYsweetspot->callback((Fl_Callback*)cb_valRTTYsweetspot);
                o->value(progdefaults.RTTYsweetspot);
              } // Fl_Value_Input* valRTTYsweetspot
              { Fl_Value_Input* o = valPSKsweetspot = new Fl_Value_Input(315, 71, 65, 20, "PSK etal");
                valPSKsweetspot->minimum(200);
                valPSKsweetspot->maximum(4000);
                valPSKsweetspot->step(1);
                valPSKsweetspot->value(1000);
                valPSKsweetspot->callback((Fl_Callback*)cb_valPSKsweetspot);
                o->value(progdefaults.PSKsweetspot);
              } // Fl_Value_Input* valPSKsweetspot
              { Fl_Check_Button* o = btnStartAtSweetSpot = new Fl_Check_Button(49, 100, 246, 25, "Start New Modem at Sweet Spot");
                btnStartAtSweetSpot->down_box(FL_DOWN_BOX);
                btnStartAtSweetSpot->value(1);
                btnStartAtSweetSpot->callback((Fl_Callback*)cb_btnStartAtSweetSpot);
                o->value(progdefaults.StartAtSweetSpot);
              } // Fl_Check_Button* btnStartAtSweetSpot
              o->end();
            } // Fl_Group* o
            tabSweetSpot->end();
          } // Fl_Group* tabSweetSpot
          { tabSpot = new Fl_Group(2, 55, 403, 170, "Spotting");
            { Fl_Group* o = new Fl_Group(2, 57, 395, 160, "PSK Reporter");
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { btnPSKRepAuto = new Fl_Check_Button(15, 80, 324, 20, "Automatically spot callsigns in decoded text");
                btnPSKRepAuto->down_box(FL_DOWN_BOX);
                btnPSKRepAuto->callback((Fl_Callback*)cb_btnPSKRepAuto);
                btnPSKRepAuto->value(progdefaults.pskrep_auto);
              } // Fl_Check_Button* btnPSKRepAuto
              { btnPSKRepLog = new Fl_Check_Button(15, 104, 327, 20, "Send reception report when logging a QSO");
                btnPSKRepLog->down_box(FL_DOWN_BOX);
                btnPSKRepLog->callback((Fl_Callback*)cb_btnPSKRepLog);
                btnPSKRepLog->value(progdefaults.pskrep_log);
              } // Fl_Check_Button* btnPSKRepLog
              { inpPSKRepHost = new Fl_Input(55, 155, 220, 24, "Host:");
                inpPSKRepHost->callback((Fl_Callback*)cb_inpPSKRepHost);
                inpPSKRepHost->when(FL_WHEN_CHANGED);
                inpPSKRepHost->value(progdefaults.pskrep_host.c_str());
              } // Fl_Input* inpPSKRepHost
              { inpPSKRepPort = new Fl_Input(322, 155, 60, 24, "Port:");
                inpPSKRepPort->callback((Fl_Callback*)cb_inpPSKRepPort);
                inpPSKRepPort->when(FL_WHEN_CHANGED);
                inpPSKRepPort->value(progdefaults.pskrep_port.c_str());
              } // Fl_Input* inpPSKRepPort
              { btnPSKRepInit = new Fl_Button(303, 186, 80, 24, "Initialize");
                btnPSKRepInit->callback((Fl_Callback*)cb_btnPSKRepInit);
              } // Fl_Button* btnPSKRepInit
              { boxPSKRepMsg = new Fl_Box(56, 186, 220, 24, "<PSK Reporter error message>");
                boxPSKRepMsg->labelfont(2);
                boxPSKRepMsg->label(0);
              } // Fl_Box* boxPSKRepMsg
              { btnPSKRepQRG = new Fl_Check_Button(15, 128, 357, 20, "Report QRG (enable only if you have rig control!)");
                btnPSKRepQRG->down_box(FL_DOWN_BOX);
                btnPSKRepQRG->callback((Fl_Callback*)cb_btnPSKRepQRG);
                btnPSKRepQRG->value(progdefaults.pskrep_qrg);
              } // Fl_Check_Button* btnPSKRepQRG
              o->end();
            } // Fl_Group* o
            tabSpot->end();
          } // Fl_Group* tabSpot
          tabsMisc->end();
        } // Fl_Tabs* tabsMisc
        tabMisc->end();
      } // Fl_Group* tabMisc
      { tabModems = new Fl_Group(0, 25, 400, 195, "Modem");
        tabModems->color((Fl_Color)51);
        tabModems->selection_color((Fl_Color)51);
        tabModems->hide();
        { tabsModems = new Fl_Tabs(0, 25, 400, 195);
          tabsModems->color((Fl_Color)51);
          tabsModems->selection_color((Fl_Color)10);
          tabsModems->align(FL_ALIGN_TOP_RIGHT);
          { tabCW = new Fl_Group(0, 50, 400, 170, "CW");
            tabCW->hide();
            { Fl_Tabs* o = new Fl_Tabs(0, 55, 400, 165);
              o->selection_color((Fl_Color)215);
              { Fl_Group* o = new Fl_Group(0, 85, 400, 135, "CW Ops");
                o->align(FL_ALIGN_TOP_LEFT);
                { Fl_Group* o = new Fl_Group(4, 85, 392, 130);
                o->box(FL_ENGRAVED_FRAME);
                { Fl_Value_Slider* o = sldrCWbandwidth = new Fl_Value_Slider(64, 94, 325, 20, "BW");
                sldrCWbandwidth->tooltip("DSP filter bandwidth");
                sldrCWbandwidth->type(5);
                sldrCWbandwidth->color(FL_BACKGROUND2_COLOR);
                sldrCWbandwidth->minimum(10);
                sldrCWbandwidth->maximum(500);
                sldrCWbandwidth->step(10);
                sldrCWbandwidth->value(150);
                sldrCWbandwidth->textsize(14);
                sldrCWbandwidth->callback((Fl_Callback*)cb_sldrCWbandwidth);
                sldrCWbandwidth->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWbandwidth);
                } // Fl_Value_Slider* sldrCWbandwidth
                { Fl_Counter* o = cntCWrange = new Fl_Counter(139, 118, 65, 20, "Rx Trkg Rng");
                cntCWrange->tooltip("WPM tracking range");
                cntCWrange->type(1);
                cntCWrange->minimum(5);
                cntCWrange->maximum(25);
                cntCWrange->step(1);
                cntCWrange->value(10);
                cntCWrange->callback((Fl_Callback*)cb_cntCWrange);
                cntCWrange->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWrange);
                } // Fl_Counter* cntCWrange
                { Fl_Check_Button* o = btnCWrcvTrack = new Fl_Check_Button(214, 118, 20, 20, "Enable Rx Trkg");
                btnCWrcvTrack->down_box(FL_DOWN_BOX);
                btnCWrcvTrack->value(1);
                btnCWrcvTrack->callback((Fl_Callback*)cb_btnCWrcvTrack);
                btnCWrcvTrack->align(FL_ALIGN_RIGHT);
                o->value(progdefaults.CWtrack);
                } // Fl_Check_Button* btnCWrcvTrack
                { valCWrcvWPM = new Fl_Value_Output(64, 142, 35, 20, "RxWPM");
                valCWrcvWPM->color(FL_BACKGROUND2_COLOR);
                valCWrcvWPM->callback((Fl_Callback*)cb_valCWrcvWPM);
                } // Fl_Value_Output* valCWrcvWPM
                { prgsCWrcvWPM = new Fl_Progress(99, 142, 290, 20);
                prgsCWrcvWPM->color(FL_INACTIVE_COLOR);
                prgsCWrcvWPM->selection_color((Fl_Color)110);
                prgsCWrcvWPM->align(FL_ALIGN_CENTER);
                } // Fl_Progress* prgsCWrcvWPM
                { Fl_Value_Slider* o = sldrCWxmtWPM = new Fl_Value_Slider(64, 164, 325, 20, "TxWPM");
                sldrCWxmtWPM->type(5);
                sldrCWxmtWPM->color((Fl_Color)215);
                sldrCWxmtWPM->minimum(5);
                sldrCWxmtWPM->maximum(100);
                sldrCWxmtWPM->step(1);
                sldrCWxmtWPM->value(20);
                sldrCWxmtWPM->textsize(14);
                sldrCWxmtWPM->callback((Fl_Callback*)cb_sldrCWxmtWPM);
                sldrCWxmtWPM->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWspeed);
                } // Fl_Value_Slider* sldrCWxmtWPM
                { Fl_Counter* o = cntCWlowerlimit = new Fl_Counter(202, 189, 65, 20, "Lower");
                cntCWlowerlimit->tooltip("Lower WPM limit");
                cntCWlowerlimit->type(1);
                cntCWlowerlimit->minimum(5);
                cntCWlowerlimit->maximum(20);
                cntCWlowerlimit->step(5);
                cntCWlowerlimit->value(10);
                cntCWlowerlimit->callback((Fl_Callback*)cb_cntCWlowerlimit);
                cntCWlowerlimit->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWlowerlimit);
                } // Fl_Counter* cntCWlowerlimit
                { Fl_Counter* o = cntCWupperlimit = new Fl_Counter(324, 189, 65, 20, "Upper");
                cntCWupperlimit->tooltip("Upper WPM limit");
                cntCWupperlimit->type(1);
                cntCWupperlimit->minimum(25);
                cntCWupperlimit->maximum(200);
                cntCWupperlimit->step(5);
                cntCWupperlimit->value(100);
                cntCWupperlimit->callback((Fl_Callback*)cb_cntCWupperlimit);
                cntCWupperlimit->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWupperlimit);
                } // Fl_Counter* cntCWupperlimit
                { Fl_Counter* o = cntCWdefWPM = new Fl_Counter(64, 189, 64, 21, "Default");
                cntCWdefWPM->tooltip("Default WPM");
                cntCWdefWPM->type(1);
                cntCWdefWPM->minimum(5);
                cntCWdefWPM->maximum(200);
                cntCWdefWPM->step(1);
                cntCWdefWPM->value(18);
                cntCWdefWPM->callback((Fl_Callback*)cb_cntCWdefWPM);
                cntCWdefWPM->align(FL_ALIGN_LEFT);
                o->value(progdefaults.defCWspeed);
                } // Fl_Counter* cntCWdefWPM
                o->end();
                } // Fl_Group* o
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(0, 80, 400, 140, "Timing / QSK");
                o->align(FL_ALIGN_TOP_LEFT);
                o->hide();
                { Fl_Group* o = new Fl_Group(5, 85, 390, 65, "Timing");
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Counter* o = cntCWweight = new Fl_Counter(60, 114, 65, 20, "Wt. %");
                cntCWweight->tooltip("Dot to Dot-Space Ratio");
                cntCWweight->type(1);
                cntCWweight->minimum(20);
                cntCWweight->maximum(80);
                cntCWweight->step(1);
                cntCWweight->value(50);
                cntCWweight->callback((Fl_Callback*)cb_cntCWweight);
                cntCWweight->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWweight);
                } // Fl_Counter* cntCWweight
                { Fl_Counter* o = cntCWdash2dot = new Fl_Counter(201, 114, 64, 21, "Dash/Dot");
                cntCWdash2dot->tooltip("Dash to Dot Ratio");
                cntCWdash2dot->type(1);
                cntCWdash2dot->minimum(2.5);
                cntCWdash2dot->maximum(4);
                cntCWdash2dot->step(0.1);
                cntCWdash2dot->value(3);
                cntCWdash2dot->callback((Fl_Callback*)cb_cntCWdash2dot);
                cntCWdash2dot->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWdash2dot);
                } // Fl_Counter* cntCWdash2dot
                { Fl_Counter* o = cntCWrisetime = new Fl_Counter(321, 114, 65, 21, "Edge");
                cntCWrisetime->type(1);
                cntCWrisetime->minimum(0);
                cntCWrisetime->maximum(15);
                cntCWrisetime->step(0.1);
                cntCWrisetime->value(4);
                cntCWrisetime->callback((Fl_Callback*)cb_cntCWrisetime);
                cntCWrisetime->align(FL_ALIGN_LEFT);
                o->value(progdefaults.CWrisetime);
                } // Fl_Counter* cntCWrisetime
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(5, 150, 390, 65, "QSK");
                o->box(FL_ENGRAVED_FRAME);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Check_Button* o = btnQSK = new Fl_Check_Button(175, 175, 25, 15, "QSK on right channel");
                btnQSK->tooltip("Enable QSK on right Channel");
                btnQSK->down_box(FL_DOWN_BOX);
                btnQSK->callback((Fl_Callback*)cb_btnQSK);
                btnQSK->align(FL_ALIGN_LEFT);
                o->value(progdefaults.QSK);
                } // Fl_Check_Button* btnQSK
                { Fl_Counter* o = cntPreTiming = new Fl_Counter(215, 172, 64, 21, "Pre Timing");
                cntPreTiming->tooltip("Msec pre-keydown");
                cntPreTiming->type(1);
                cntPreTiming->minimum(0);
                cntPreTiming->maximum(50);
                cntPreTiming->step(0.5);
                cntPreTiming->value(4);
                cntPreTiming->callback((Fl_Callback*)cb_cntPreTiming);
                o->value(progdefaults.CWpre);
                o->maximum((int)(2400/progdefaults.CWspeed)/2.0);
                } // Fl_Counter* cntPreTiming
                { Fl_Counter* o = cntPostTiming = new Fl_Counter(315, 172, 64, 21, "Post Timing");
                cntPostTiming->tooltip("Msec post-keydown");
                cntPostTiming->type(1);
                cntPostTiming->minimum(-20);
                cntPostTiming->maximum(50);
                cntPostTiming->step(0.5);
                cntPostTiming->value(4);
                cntPostTiming->callback((Fl_Callback*)cb_cntPostTiming);
                o->value(progdefaults.CWpre);
                o->maximum((int)(2400/progdefaults.CWspeed)/2.0);
                } // Fl_Counter* cntPostTiming
                o->end();
                } // Fl_Group* o
                o->end();
              } // Fl_Group* o
              o->end();
            } // Fl_Tabs* o
            tabCW->end();
          } // Fl_Group* tabCW
          { tabDomEX = new Fl_Group(0, 50, 400, 170, "Dom");
            tabDomEX->color((Fl_Color)51);
            tabDomEX->selection_color((Fl_Color)51);
            tabDomEX->hide();
            { txtSecondary = new Fl_Input(20, 75, 360, 44, "Secondary Text");
              txtSecondary->tooltip("Text to send during keyboard idle times");
              txtSecondary->type(4);
              txtSecondary->callback((Fl_Callback*)cb_txtSecondary);
              txtSecondary->align(FL_ALIGN_TOP_LEFT);
              txtSecondary->when(FL_WHEN_CHANGED);
            } // Fl_Input* txtSecondary
            { Fl_Counter* o = valDominoEX_BW = new Fl_Counter(20, 130, 63, 21, "BW factor:");
              valDominoEX_BW->tooltip("DSP filter BW relative to signal width");
              valDominoEX_BW->type(1);
              valDominoEX_BW->minimum(1);
              valDominoEX_BW->maximum(2);
              valDominoEX_BW->step(0.1);
              valDominoEX_BW->value(1.5);
              valDominoEX_BW->callback((Fl_Callback*)cb_valDominoEX_BW);
              o->value(progdefaults.DOMINOEX_BW);
            } // Fl_Counter* valDominoEX_BW
            { Fl_Check_Button* o = valDominoEX_FILTER = new Fl_Check_Button(110, 130, 83, 20, "Filter ON");
              valDominoEX_FILTER->tooltip("Enable DSP filtering");
              valDominoEX_FILTER->down_box(FL_DOWN_BOX);
              valDominoEX_FILTER->value(1);
              valDominoEX_FILTER->callback((Fl_Callback*)cb_valDominoEX_FILTER);
              o->value(progdefaults.DOMINOEX_FILTER);
            } // Fl_Check_Button* valDominoEX_FILTER
            { Fl_Check_Button* o = chkDominoEX_FEC = new Fl_Check_Button(220, 130, 51, 20, "FEC");
              chkDominoEX_FEC->tooltip("Add MultiPSK compatible FEC");
              chkDominoEX_FEC->down_box(FL_DOWN_BOX);
              chkDominoEX_FEC->callback((Fl_Callback*)cb_chkDominoEX_FEC);
              o->value(progdefaults.DOMINOEX_FEC);
            } // Fl_Check_Button* chkDominoEX_FEC
            { Fl_Counter* o = valDominoEX_PATHS = new Fl_Counter(20, 174, 63, 21, "Paths");
              valDominoEX_PATHS->type(1);
              valDominoEX_PATHS->minimum(4);
              valDominoEX_PATHS->maximum(8);
              valDominoEX_PATHS->step(1);
              valDominoEX_PATHS->value(5);
              valDominoEX_PATHS->callback((Fl_Callback*)cb_valDominoEX_PATHS);
              valDominoEX_PATHS->hide();
              o->value(progdefaults.DOMINOEX_PATHS);
            } // Fl_Counter* valDominoEX_PATHS
            { Fl_Value_Slider* o = valDomCWI = new Fl_Value_Slider(125, 179, 260, 21, "CWI threshold:");
              valDomCWI->tooltip("CWI detection and suppression");
              valDomCWI->type(1);
              valDomCWI->step(0.01);
              valDomCWI->textsize(14);
              valDomCWI->callback((Fl_Callback*)cb_valDomCWI);
              valDomCWI->align(FL_ALIGN_LEFT);
              o->value(progdefaults.DomCWI);
            } // Fl_Value_Slider* valDomCWI
            tabDomEX->end();
          } // Fl_Group* tabDomEX
          { tabFeld = new Fl_Group(0, 50, 400, 170, "Feld");
            tabFeld->color((Fl_Color)51);
            tabFeld->selection_color((Fl_Color)51);
            tabFeld->hide();
            { Fl_Choice* o = selHellFont = new Fl_Choice(260, 62, 122, 20, "Feld Hell Font:");
              selHellFont->down_box(FL_BORDER_BOX);
              selHellFont->labelfont(4);
              selHellFont->textfont(4);
              selHellFont->callback((Fl_Callback*)cb_selHellFont);
              o->add(szFeldFonts);
              o->value(progdefaults.feldfontnbr);
            } // Fl_Choice* selHellFont
            { Fl_Value_Slider* o = sldrHellBW = new Fl_Value_Slider(30, 190, 345, 20, "Filter BW");
              sldrHellBW->type(1);
              sldrHellBW->color((Fl_Color)215);
              sldrHellBW->minimum(10);
              sldrHellBW->maximum(2400);
              sldrHellBW->step(5);
              sldrHellBW->value(400);
              sldrHellBW->textsize(14);
              sldrHellBW->callback((Fl_Callback*)cb_sldrHellBW);
              sldrHellBW->align(FL_ALIGN_TOP_LEFT);
              o->value(progdefaults.HELL_BW);
            } // Fl_Value_Slider* sldrHellBW
            { Fl_Check_Button* o = btnHellXmtWidth = new Fl_Check_Button(175, 175, 113, 15, "2x Xmt Width");
              btnHellXmtWidth->down_box(FL_DOWN_BOX);
              btnHellXmtWidth->callback((Fl_Callback*)cb_btnHellXmtWidth);
              btnHellXmtWidth->hide();
              o->value(progdefaults.HellXmtWidth);
            } // Fl_Check_Button* btnHellXmtWidth
            { Fl_Check_Button* o = btnHellRcvWidth = new Fl_Check_Button(40, 113, 130, 15, "1/2 x Rcv Width");
              btnHellRcvWidth->down_box(FL_DOWN_BOX);
              btnHellRcvWidth->callback((Fl_Callback*)cb_btnHellRcvWidth);
              o->value(progdefaults.HellRcvWidth);
            } // Fl_Check_Button* btnHellRcvWidth
            { Fl_Check_Button* o = btnBlackboard = new Fl_Check_Button(40, 134, 100, 15, "blackboard");
              btnBlackboard->down_box(FL_DOWN_BOX);
              btnBlackboard->callback((Fl_Callback*)cb_btnBlackboard);
              o->value(progdefaults.HellBlackboard);
            } // Fl_Check_Button* btnBlackboard
            { Fl_Group* o = new Fl_Group(189, 90, 195, 85, "Pulse Shape");
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnHellFastAttack = new Fl_Check_Button(199, 110, 169, 15, "Fast Attack (2 msec)");
                btnHellFastAttack->down_box(FL_DOWN_BOX);
                btnHellFastAttack->callback((Fl_Callback*)cb_btnHellFastAttack);
                o->value(progdefaults.HellPulseFast);
              } // Fl_Check_Button* btnHellFastAttack
              { Fl_Check_Button* o = btnHellSlowAttack = new Fl_Check_Button(199, 131, 169, 15, "Slow Attack (4 msec)");
                btnHellSlowAttack->down_box(FL_DOWN_BOX);
                btnHellSlowAttack->value(1);
                btnHellSlowAttack->callback((Fl_Callback*)cb_btnHellSlowAttack);
                o->value(!progdefaults.HellPulseFast);
              } // Fl_Check_Button* btnHellSlowAttack
              o->end();
            } // Fl_Group* o
            { Fl_Check_Button* o = btnFeldHellIdle = new Fl_Check_Button(40, 155, 135, 15, "Xmt (.) Idle Char");
              btnFeldHellIdle->down_box(FL_DOWN_BOX);
              btnFeldHellIdle->value(1);
              btnFeldHellIdle->callback((Fl_Callback*)cb_btnFeldHellIdle);
              o->value(progdefaults.HellXmtIdle);
            } // Fl_Check_Button* btnFeldHellIdle
            { Fl_Spinner* o = valHellXmtWidth = new Fl_Spinner(40, 80, 40, 25, "Xmt Width");
              valHellXmtWidth->maximum(3);
              valHellXmtWidth->value(1);
              valHellXmtWidth->callback((Fl_Callback*)cb_valHellXmtWidth);
              valHellXmtWidth->align(FL_ALIGN_RIGHT);
              o->value(progdefaults.HellXmtWidth);
            } // Fl_Spinner* valHellXmtWidth
            tabFeld->end();
          } // Fl_Group* tabFeld
          { tabMT63 = new Fl_Group(0, 50, 400, 170, "MT-63");
            tabMT63->hide();
            { Fl_Group* o = new Fl_Group(5, 60, 390, 155);
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnMT63_8bit = new Fl_Check_Button(55, 90, 163, 15, "8 bit extended chars");
                btnMT63_8bit->down_box(FL_DOWN_BOX);
                btnMT63_8bit->callback((Fl_Callback*)cb_btnMT63_8bit);
                o->value(progdefaults.mt63_8bit);
              } // Fl_Check_Button* btnMT63_8bit
              { Fl_Check_Button* o = btnmt63_interleave = new Fl_Check_Button(55, 120, 186, 15, "64 bit interleave (long)");
                btnmt63_interleave->down_box(FL_DOWN_BOX);
                btnmt63_interleave->callback((Fl_Callback*)cb_btnmt63_interleave);
                o->value(0);if (progdefaults.mt63_interleave == 64) o->value(1);
              } // Fl_Check_Button* btnmt63_interleave
              o->end();
            } // Fl_Group* o
            tabMT63->end();
          } // Fl_Group* tabMT63
          { tabOlivia = new Fl_Group(0, 50, 400, 170, "Olivia");
            tabOlivia->color((Fl_Color)51);
            tabOlivia->selection_color((Fl_Color)51);
            tabOlivia->hide();
            { Fl_Choice* o = mnuOlivia_Tones = new Fl_Choice(105, 72, 70, 22, "Tones");
              mnuOlivia_Tones->down_box(FL_BORDER_BOX);
              mnuOlivia_Tones->callback((Fl_Callback*)cb_mnuOlivia_Tones);
              o->add(szOliviaTones);
              o->value(2);
            } // Fl_Choice* mnuOlivia_Tones
            { Fl_Choice* o = mnuOlivia_Bandwidth = new Fl_Choice(270, 72, 85, 22, "Bandwidth");
              mnuOlivia_Bandwidth->down_box(FL_BORDER_BOX);
              mnuOlivia_Bandwidth->callback((Fl_Callback*)cb_mnuOlivia_Bandwidth);
              o->add(szOliviaBandwidth);
              o->value(2);
            } // Fl_Choice* mnuOlivia_Bandwidth
            { cntOlivia_smargin = new Fl_Counter(90, 105, 85, 22, "RX sync tune margin");
              cntOlivia_smargin->type(1);
              cntOlivia_smargin->minimum(2);
              cntOlivia_smargin->maximum(128);
              cntOlivia_smargin->step(1);
              cntOlivia_smargin->value(8);
              cntOlivia_smargin->callback((Fl_Callback*)cb_cntOlivia_smargin);
              cntOlivia_smargin->align(FL_ALIGN_RIGHT);
            } // Fl_Counter* cntOlivia_smargin
            { cntOlivia_sinteg = new Fl_Counter(90, 135, 85, 22, "RX sync integration period");
              cntOlivia_sinteg->type(1);
              cntOlivia_sinteg->minimum(2);
              cntOlivia_sinteg->maximum(128);
              cntOlivia_sinteg->step(1);
              cntOlivia_sinteg->value(4);
              cntOlivia_sinteg->callback((Fl_Callback*)cb_cntOlivia_sinteg);
              cntOlivia_sinteg->align(FL_ALIGN_RIGHT);
            } // Fl_Counter* cntOlivia_sinteg
            { btnOlivia_8bit = new Fl_Check_Button(90, 173, 163, 15, "8 bit extended chars");
              btnOlivia_8bit->down_box(FL_DOWN_BOX);
              btnOlivia_8bit->callback((Fl_Callback*)cb_btnOlivia_8bit);
            } // Fl_Check_Button* btnOlivia_8bit
            tabOlivia->end();
          } // Fl_Group* tabOlivia
          { tabPSK = new Fl_Group(0, 50, 400, 170, "Psk");
            { Fl_Tabs* o = new Fl_Tabs(0, 50, 400, 170);
              o->selection_color((Fl_Color)215);
              { Fl_Group* o = new Fl_Group(0, 80, 400, 136, "General");
                o->align(FL_ALIGN_TOP_LEFT);
                { Fl_Counter* o = cntSearchRange = new Fl_Counter(30, 94, 75, 21, "Acq Srch Range");
                cntSearchRange->tooltip("Capture signals within this frequency range");
                cntSearchRange->type(1);
                cntSearchRange->minimum(10);
                cntSearchRange->maximum(500);
                cntSearchRange->step(10);
                cntSearchRange->value(200);
                cntSearchRange->callback((Fl_Callback*)cb_cntSearchRange);
                cntSearchRange->align(FL_ALIGN_RIGHT);
                o->value(progdefaults.SearchRange);
                } // Fl_Counter* cntSearchRange
                { Fl_Counter* o = cntACQsn = new Fl_Counter(225, 94, 75, 21, "Acq s/n (db)");
                cntACQsn->tooltip("Capture signals over this threshold");
                cntACQsn->type(1);
                cntACQsn->minimum(3);
                cntACQsn->maximum(20);
                cntACQsn->step(1);
                cntACQsn->value(6);
                cntACQsn->callback((Fl_Callback*)cb_cntACQsn);
                cntACQsn->align(FL_ALIGN_RIGHT);
                o->value(progdefaults.ACQsn);
                } // Fl_Counter* cntACQsn
                { Fl_Group* o = new Fl_Group(5, 143, 390, 73, "S/N, Imd Behavior");
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Check_Button* o = new Fl_Check_Button(190, 172, 70, 15, "Dim");
                o->tooltip("Check for dimming / uncheck for clear");
                o->down_box(FL_DOWN_BOX);
                o->callback((Fl_Callback*)cb_Dim);
                o->value(progdefaults.StatusDim);
                } // Fl_Check_Button* o
                { Fl_Counter* o = new Fl_Counter(30, 169, 75, 21, "Seconds to ");
                o->tooltip("Time delay in seconds to dim / clear (0 disables)");
                o->type(1);
                o->minimum(0);
                o->maximum(30);
                o->step(1);
                o->callback((Fl_Callback*)cb_Seconds);
                o->align(FL_ALIGN_RIGHT);
                o->value(progdefaults.StatusTimeout);
                } // Fl_Counter* o
                o->end();
                } // Fl_Group* o
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(0, 75, 400, 140, "Mail");
                o->align(FL_ALIGN_TOP_LEFT);
                o->hide();
                { Fl_Check_Button* o = btnPSKmailSweetSpot = new Fl_Check_Button(55, 100, 130, 20, "use sweetspot");
                btnPSKmailSweetSpot->tooltip("Return Tx frequency to sweetspot");
                btnPSKmailSweetSpot->down_box(FL_DOWN_BOX);
                btnPSKmailSweetSpot->value(1);
                btnPSKmailSweetSpot->callback((Fl_Callback*)cb_btnPSKmailSweetSpot);
                o->value(progdefaults.PSKmailSweetSpot);
                } // Fl_Check_Button* btnPSKmailSweetSpot
                { Fl_Counter* o = cntServerOffset = new Fl_Counter(55, 129, 80, 21, "Server Search Range");
                cntServerOffset->tooltip("Listen for signals within this range");
                cntServerOffset->type(1);
                cntServerOffset->minimum(10);
                cntServerOffset->maximum(500);
                cntServerOffset->step(10);
                cntServerOffset->value(200);
                cntServerOffset->callback((Fl_Callback*)cb_cntServerOffset);
                cntServerOffset->align(FL_ALIGN_RIGHT);
                o->value(progdefaults.SearchRange);
                } // Fl_Counter* cntServerOffset
                o->end();
              } // Fl_Group* o
              { Fl_Group* o = new Fl_Group(0, 80, 400, 140, "Viewer");
                o->align(FL_ALIGN_TOP_LEFT);
                o->hide();
                { Fl_Check_Button* o = btnMarquee = new Fl_Check_Button(10, 110, 120, 15, "Marquee style");
                btnMarquee->tooltip("Continuous horizontal scroll of Rx data");
                btnMarquee->down_box(FL_DOWN_BOX);
                btnMarquee->callback((Fl_Callback*)cb_btnMarquee);
                o->value(progdefaults.VIEWERmarquee);
                } // Fl_Check_Button* btnMarquee
                { Fl_Check_Button* o = btnShowFrequencies = new Fl_Check_Button(10, 154, 109, 15, "Show Freq\'s");
                btnShowFrequencies->tooltip("Show frequencies on left");
                btnShowFrequencies->down_box(FL_DOWN_BOX);
                btnShowFrequencies->callback((Fl_Callback*)cb_btnShowFrequencies);
                o->value(progdefaults.VIEWERshowfreq);
                } // Fl_Check_Button* btnShowFrequencies
                { Fl_Spinner* o = cntChannels = new Fl_Spinner(265, 150, 39, 25, "# Channels");
                cntChannels->tooltip("Number of channels to monitor");
                cntChannels->value(1);
                cntChannels->callback((Fl_Callback*)cb_cntChannels);
                cntChannels->align(FL_ALIGN_RIGHT);
                o->minimum(5);
                o->maximum(30);
                o->step(1);
                o->value(progdefaults.VIEWERchannels);
                } // Fl_Spinner* cntChannels
                { Fl_Spinner* o = cntStartFrequency = new Fl_Spinner(134, 150, 50, 25, "Start Freq");
                cntStartFrequency->value(1);
                cntStartFrequency->callback((Fl_Callback*)cb_cntStartFrequency);
                cntStartFrequency->align(FL_ALIGN_RIGHT);
                o->minimum(200);
                o->maximum(1000);
                o->step(100);
                o->value(progdefaults.VIEWERstart);
                } // Fl_Spinner* cntStartFrequency
                { Fl_Spinner* o = cntTimeout = new Fl_Spinner(135, 105, 50, 25, "Aging (sec)");
                cntTimeout->tooltip("Clear channel after # seconds inactivity");
                cntTimeout->value(1);
                cntTimeout->callback((Fl_Callback*)cb_cntTimeout);
                cntTimeout->align(FL_ALIGN_RIGHT);
                o->minimum(10);
                o->maximum(180);
                o->step(1);
                o->value(progdefaults.VIEWERtimeout);
                } // Fl_Spinner* cntTimeout
                o->end();
              } // Fl_Group* o
              o->end();
            } // Fl_Tabs* o
            tabPSK->end();
          } // Fl_Group* tabPSK
          { tabRTTY = new Fl_Group(0, 50, 400, 170, "RTTY");
            tabRTTY->color((Fl_Color)51);
            tabRTTY->selection_color((Fl_Color)51);
            tabRTTY->hide();
            { Fl_Choice* o = selShift = new Fl_Choice(48, 60, 77, 22, "Shift");
              selShift->down_box(FL_BORDER_BOX);
              selShift->callback((Fl_Callback*)cb_selShift);
              selShift->when(FL_WHEN_CHANGED);
              o->add(szShifts);
            } // Fl_Choice* selShift
            { Fl_Choice* o = selBaud = new Fl_Choice(48, 84, 77, 22, "Baud");
              selBaud->down_box(FL_BORDER_BOX);
              selBaud->callback((Fl_Callback*)cb_selBaud);
              selBaud->when(FL_WHEN_CHANGED);
              o->add(szBauds);
            } // Fl_Choice* selBaud
            { Fl_Choice* o = selBits = new Fl_Choice(48, 109, 77, 22, "Bits");
              selBits->down_box(FL_BORDER_BOX);
              selBits->callback((Fl_Callback*)cb_selBits);
              selBits->when(FL_WHEN_CHANGED);
              o->add(szSelBits);
            } // Fl_Choice* selBits
            { Fl_Choice* o = selParity = new Fl_Choice(48, 133, 77, 22, "Parity");
              selParity->down_box(FL_BORDER_BOX);
              selParity->callback((Fl_Callback*)cb_selParity);
              selParity->when(FL_WHEN_CHANGED);
              o->add(szParity);
            } // Fl_Choice* selParity
            { Fl_Choice* o = selStopBits = new Fl_Choice(48, 158, 77, 22, "Stop");
              selStopBits->down_box(FL_BORDER_BOX);
              selStopBits->callback((Fl_Callback*)cb_selStopBits);
              selStopBits->when(FL_WHEN_CHANGED);
              o->add(szStopBits);
            } // Fl_Choice* selStopBits
            { Fl_Check_Button* o = chkPseudoFSK = new Fl_Check_Button(98, 185, 22, 22, "PseudoFSK");
              chkPseudoFSK->down_box(FL_DOWN_BOX);
              chkPseudoFSK->callback((Fl_Callback*)cb_chkPseudoFSK);
              chkPseudoFSK->align(FL_ALIGN_LEFT);
              o->value(progdefaults.PseudoFSK);
            } // Fl_Check_Button* chkPseudoFSK
            { Fl_Check_Button* o = btnCRCRLF = new Fl_Check_Button(364, 60, 22, 22, "CR-CR-LF");
              btnCRCRLF->down_box(FL_DOWN_BOX);
              btnCRCRLF->callback((Fl_Callback*)cb_btnCRCRLF);
              btnCRCRLF->align(FL_ALIGN_LEFT);
              btnCRCRLF->when(FL_WHEN_RELEASE_ALWAYS);
              o->value(progdefaults.rtty_crcrlf);
            } // Fl_Check_Button* btnCRCRLF
            { Fl_Check_Button* o = btnAUTOCRLF = new Fl_Check_Button(364, 88, 22, 22, "AutoCRLF");
              btnAUTOCRLF->down_box(FL_DOWN_BOX);
              btnAUTOCRLF->callback((Fl_Callback*)cb_btnAUTOCRLF);
              btnAUTOCRLF->align(FL_ALIGN_LEFT);
              o->value(progdefaults.rtty_autocrlf);
            } // Fl_Check_Button* btnAUTOCRLF
            { cntrAUTOCRLF = new Fl_Counter(321, 117, 65, 20, "after:");
              cntrAUTOCRLF->type(1);
              cntrAUTOCRLF->minimum(68);
              cntrAUTOCRLF->maximum(80);
              cntrAUTOCRLF->step(1);
              cntrAUTOCRLF->value(72);
              cntrAUTOCRLF->callback((Fl_Callback*)cb_cntrAUTOCRLF);
              cntrAUTOCRLF->align(FL_ALIGN_LEFT);
            } // Fl_Counter* cntrAUTOCRLF
            { Fl_Group* o = new Fl_Group(135, 60, 130, 60, "AFC");
              o->box(FL_ENGRAVED_FRAME);
              o->color((Fl_Color)51);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { btnRTTYafc[0] = new Fl_Round_Button(190, 60, 70, 20, "Slow");
                btnRTTYafc[0]->type(102);
                btnRTTYafc[0]->down_box(FL_DIAMOND_DOWN_BOX);
                btnRTTYafc[0]->selection_color((Fl_Color)2);
                btnRTTYafc[0]->callback((Fl_Callback*)cb_btnRTTYafc);
              } // Fl_Round_Button* btnRTTYafc[0]
              { btnRTTYafc[1] = new Fl_Round_Button(190, 82, 70, 15, "Normal");
                btnRTTYafc[1]->type(102);
                btnRTTYafc[1]->down_box(FL_DIAMOND_DOWN_BOX);
                btnRTTYafc[1]->value(1);
                btnRTTYafc[1]->selection_color((Fl_Color)2);
                btnRTTYafc[1]->callback((Fl_Callback*)cb_btnRTTYafc1);
              } // Fl_Round_Button* btnRTTYafc[1]
              { btnRTTYafc[2] = new Fl_Round_Button(190, 100, 70, 15, "Fast");
                btnRTTYafc[2]->type(102);
                btnRTTYafc[2]->down_box(FL_DIAMOND_DOWN_BOX);
                btnRTTYafc[2]->selection_color((Fl_Color)2);
                btnRTTYafc[2]->callback((Fl_Callback*)cb_btnRTTYafc2);
              } // Fl_Round_Button* btnRTTYafc[2]
              o->end();
            } // Fl_Group* o
            { Fl_Check_Button* o = btnPreferXhairScope = new Fl_Check_Button(364, 153, 22, 22, "X-scope");
              btnPreferXhairScope->down_box(FL_DOWN_BOX);
              btnPreferXhairScope->callback((Fl_Callback*)cb_btnPreferXhairScope);
              btnPreferXhairScope->align(FL_ALIGN_LEFT);
              o->value(progdefaults.PreferXhairScope);
            } // Fl_Check_Button* btnPreferXhairScope
            { Fl_Check_Button* o = chkXagc = new Fl_Check_Button(364, 185, 22, 22, "X-agc");
              chkXagc->down_box(FL_DOWN_BOX);
              chkXagc->callback((Fl_Callback*)cb_chkXagc);
              chkXagc->align(FL_ALIGN_LEFT);
              chkXagc->hide();
              o->value(progdefaults.Xagc);
            } // Fl_Check_Button* chkXagc
            { Fl_Group* o = new Fl_Group(135, 119, 130, 62, "Unshift On Space");
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = chkUOSrx = new Fl_Check_Button(167, 148, 24, 18, "Rx");
                chkUOSrx->down_box(FL_DOWN_BOX);
                chkUOSrx->callback((Fl_Callback*)cb_chkUOSrx);
                chkUOSrx->align(FL_ALIGN_LEFT);
                o->value(progdefaults.UOSrx);
              } // Fl_Check_Button* chkUOSrx
              { Fl_Check_Button* o = chkUOStx = new Fl_Check_Button(224, 147, 24, 19, "Tx");
                chkUOStx->down_box(FL_DOWN_BOX);
                chkUOStx->callback((Fl_Callback*)cb_chkUOStx);
                chkUOStx->align(FL_ALIGN_LEFT);
                o->value(progdefaults.UOStx);
              } // Fl_Check_Button* chkUOStx
              o->end();
            } // Fl_Group* o
            tabRTTY->end();
          } // Fl_Group* tabRTTY
          { tabTHOR = new Fl_Group(0, 50, 400, 170, "Thor");
            tabTHOR->color((Fl_Color)51);
            tabTHOR->selection_color((Fl_Color)51);
            tabTHOR->hide();
            { txtTHORSecondary = new Fl_Input(20, 75, 360, 44, "Secondary Text");
              txtTHORSecondary->tooltip("Text to send during keyboard idle times");
              txtTHORSecondary->type(4);
              txtTHORSecondary->callback((Fl_Callback*)cb_txtTHORSecondary);
              txtTHORSecondary->align(FL_ALIGN_TOP_LEFT);
              txtTHORSecondary->when(FL_WHEN_CHANGED);
            } // Fl_Input* txtTHORSecondary
            { Fl_Counter* o = valTHOR_BW = new Fl_Counter(20, 130, 63, 21, "BW factor:");
              valTHOR_BW->tooltip("DSP filter BW relative to signal width");
              valTHOR_BW->type(1);
              valTHOR_BW->minimum(1);
              valTHOR_BW->maximum(2);
              valTHOR_BW->step(0.1);
              valTHOR_BW->value(1.5);
              valTHOR_BW->callback((Fl_Callback*)cb_valTHOR_BW);
              o->value(progdefaults.THOR_BW);
            } // Fl_Counter* valTHOR_BW
            { Fl_Check_Button* o = valTHOR_FILTER = new Fl_Check_Button(110, 130, 83, 20, "Filter ON");
              valTHOR_FILTER->tooltip("Enable DSP filtering");
              valTHOR_FILTER->down_box(FL_DOWN_BOX);
              valTHOR_FILTER->value(1);
              valTHOR_FILTER->callback((Fl_Callback*)cb_valTHOR_FILTER);
              o->value(progdefaults.THOR_FILTER);
            } // Fl_Check_Button* valTHOR_FILTER
            { Fl_Counter* o = valTHOR_PATHS = new Fl_Counter(20, 174, 63, 21, "Paths");
              valTHOR_PATHS->type(1);
              valTHOR_PATHS->minimum(4);
              valTHOR_PATHS->maximum(8);
              valTHOR_PATHS->step(1);
              valTHOR_PATHS->value(5);
              valTHOR_PATHS->callback((Fl_Callback*)cb_valTHOR_PATHS);
              valTHOR_PATHS->hide();
              o->value(progdefaults.THOR_PATHS);
            } // Fl_Counter* valTHOR_PATHS
            { Fl_Check_Button* o = valTHOR_SOFT = new Fl_Check_Button(215, 130, 108, 20, "Soft decode");
              valTHOR_SOFT->tooltip("Detector thresholds track s/n");
              valTHOR_SOFT->down_box(FL_DOWN_BOX);
              valTHOR_SOFT->callback((Fl_Callback*)cb_valTHOR_SOFT);
              o->value(progdefaults.THOR_SOFT);
            } // Fl_Check_Button* valTHOR_SOFT
            { Fl_Value_Slider* o = valThorCWI = new Fl_Value_Slider(120, 174, 260, 21, "CWI threshold:");
              valThorCWI->tooltip("CWI detection and suppression");
              valThorCWI->type(1);
              valThorCWI->step(0.01);
              valThorCWI->textsize(14);
              valThorCWI->callback((Fl_Callback*)cb_valThorCWI);
              valThorCWI->align(FL_ALIGN_LEFT);
              o->value(progdefaults.ThorCWI);
            } // Fl_Value_Slider* valThorCWI
            tabTHOR->end();
          } // Fl_Group* tabTHOR
          tabsModems->end();
        } // Fl_Tabs* tabsModems
        tabModems->end();
      } // Fl_Group* tabModems
      { tabOperator = new Fl_Group(0, 25, 400, 195, "Oper");
        tabOperator->color((Fl_Color)51);
        tabOperator->selection_color((Fl_Color)51);
        tabOperator->callback((Fl_Callback*)cb_tabOperator);
        tabOperator->when(FL_WHEN_CHANGED);
        { inpMyCallsign = new Fl_Input(78, 36, 85, 24, "Callsign:");
          inpMyCallsign->callback((Fl_Callback*)cb_inpMyCallsign);
        } // Fl_Input* inpMyCallsign
        { inpMyName = new Fl_Input(271, 36, 120, 24, "Name:");
          inpMyName->callback((Fl_Callback*)cb_inpMyName);
        } // Fl_Input* inpMyName
        { inpMyQth = new Fl_Input(79, 63, 312, 24, "Qth:");
          inpMyQth->callback((Fl_Callback*)cb_inpMyQth);
        } // Fl_Input* inpMyQth
        { inpMyLocator = new Fl_Input(78, 116, 85, 24, "Locator:");
          inpMyLocator->callback((Fl_Callback*)cb_inpMyLocator);
        } // Fl_Input* inpMyLocator
        { Fl_Group* o = new Fl_Group(5, 145, 390, 70, "Contest Setup");
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { btnUseLeadingZeros = new Fl_Check_Button(42, 175, 154, 15, "Use Leading Zeros");
            btnUseLeadingZeros->down_box(FL_DOWN_BOX);
            btnUseLeadingZeros->value(1);
            btnUseLeadingZeros->callback((Fl_Callback*)cb_btnUseLeadingZeros);
          } // Fl_Check_Button* btnUseLeadingZeros
          { nbrContestStart = new Fl_Value_Input(216, 170, 45, 24, "Starting #:");
            nbrContestStart->minimum(1);
            nbrContestStart->maximum(10000);
            nbrContestStart->step(1);
            nbrContestStart->value(1);
            nbrContestStart->callback((Fl_Callback*)cb_nbrContestStart);
            nbrContestStart->align(FL_ALIGN_TOP);
          } // Fl_Value_Input* nbrContestStart
          { nbrContestDigits = new Fl_Value_Input(298, 170, 45, 24, "# of digits:");
            nbrContestDigits->minimum(1);
            nbrContestDigits->maximum(5);
            nbrContestDigits->step(1);
            nbrContestDigits->value(3);
            nbrContestDigits->callback((Fl_Callback*)cb_nbrContestDigits);
            nbrContestDigits->align(FL_ALIGN_TOP);
          } // Fl_Value_Input* nbrContestDigits
          o->end();
        } // Fl_Group* o
        { inpMyAntenna = new Fl_Input(78, 89, 312, 24, "Antenna:");
          inpMyAntenna->callback((Fl_Callback*)cb_inpMyAntenna);
        } // Fl_Input* inpMyAntenna
        tabOperator->end();
      } // Fl_Group* tabOperator
      { tabQRZ = new Fl_Group(0, 25, 400, 195, "Qrz");
        tabQRZ->color((Fl_Color)51);
        tabQRZ->selection_color((Fl_Color)51);
        tabQRZ->hide();
        { btnQRZnotavailable = new Fl_Round_Button(17, 45, 110, 20, "Not available");
          btnQRZnotavailable->down_box(FL_ROUND_DOWN_BOX);
          btnQRZnotavailable->value(1);
          btnQRZnotavailable->callback((Fl_Callback*)cb_btnQRZnotavailable);
          btnQRZnotavailable->value(progdefaults.QRZ == QRZ_NONE);
        } // Fl_Round_Button* btnQRZnotavailable
        { btnQRZcdrom = new Fl_Round_Button(17, 71, 103, 20, "QRZ cdrom");
          btnQRZcdrom->down_box(FL_ROUND_DOWN_BOX);
          btnQRZcdrom->callback((Fl_Callback*)cb_btnQRZcdrom);
          btnQRZcdrom->value(progdefaults.QRZ == QRZ_CD);
        } // Fl_Round_Button* btnQRZcdrom
        { btnQRZonline = new Fl_Round_Button(17, 98, 100, 20, "QRZ online");
          btnQRZonline->tooltip("This service may not be available");
          btnQRZonline->down_box(FL_ROUND_DOWN_BOX);
          btnQRZonline->callback((Fl_Callback*)cb_btnQRZonline);
          btnQRZonline->value(progdefaults.QRZ == QRZ_NET_HTML);
        } // Fl_Round_Button* btnQRZonline
        { Fl_Input* o = txtQRZpathname = new Fl_Input(140, 69, 255, 25, "at:");
          txtQRZpathname->tooltip("ie: /home/dave/CALLBK/ or C:/CALLBK/^jLeave blank to search for database");
          txtQRZpathname->callback((Fl_Callback*)cb_txtQRZpathname);
          o->value(progdefaults.QRZpathname.c_str());
        } // Fl_Input* txtQRZpathname
        { Fl_Group* o = new Fl_Group(5, 125, 390, 90, "Paid Online Subscription");
          o->box(FL_ENGRAVED_FRAME);
          o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
          { Fl_Input* o = inpQRZusername = new Fl_Input(125, 150, 90, 25, "User name");
            inpQRZusername->tooltip("subscription user name");
            inpQRZusername->callback((Fl_Callback*)cb_inpQRZusername);
            inpQRZusername->align(FL_ALIGN_RIGHT);
            o->value(progdefaults.QRZusername.c_str());
          } // Fl_Input* inpQRZusername
          { Fl_Input* o = inpQRZuserpassword = new Fl_Input(125, 180, 90, 25, "Password");
            inpQRZuserpassword->tooltip("subscription password");
            inpQRZuserpassword->callback((Fl_Callback*)cb_inpQRZuserpassword);
            inpQRZuserpassword->align(FL_ALIGN_RIGHT);
            o->value(progdefaults.QRZuserpassword.c_str());
            o->type(progdefaults.SHOWPASSWORD);
          } // Fl_Input* inpQRZuserpassword
          { btnQRZsub = new Fl_Round_Button(17, 152, 90, 20, "QRZ");
            btnQRZsub->tooltip("You need a paid QRZ on-line subscription for access");
            btnQRZsub->down_box(FL_ROUND_DOWN_BOX);
            btnQRZsub->callback((Fl_Callback*)cb_btnQRZsub);
            btnQRZsub->value(progdefaults.QRZ == QRZ_NET_SUB);
          } // Fl_Round_Button* btnQRZsub
          { btnHamcall = new Fl_Round_Button(17, 182, 90, 20, "Hamcall");
            btnHamcall->tooltip("You need a paid Hamcall on-line subscription to access");
            btnHamcall->down_box(FL_ROUND_DOWN_BOX);
            btnHamcall->callback((Fl_Callback*)cb_btnHamcall);
            btnHamcall->value(progdefaults.QRZ == QRZ_HAMCALL);
          } // Fl_Round_Button* btnHamcall
          { Fl_Button* o = btnQRZpasswordShow = new Fl_Button(305, 180, 50, 25, "Show");
            btnQRZpasswordShow->tooltip("Show / Hide user password");
            btnQRZpasswordShow->callback((Fl_Callback*)cb_btnQRZpasswordShow);
            o->label((progdefaults.SHOWPASSWORD & FL_SECRET_INPUT) ? "Show" : "Hide");
          } // Fl_Button* btnQRZpasswordShow
          o->end();
        } // Fl_Group* o
        tabQRZ->end();
      } // Fl_Group* tabQRZ
      { tabRig = new Fl_Group(0, 25, 401, 196, "Rig");
        tabRig->hide();
        { Fl_Tabs* o = new Fl_Tabs(0, 25, 401, 196);
          o->selection_color((Fl_Color)10);
          { Fl_Group* o = new Fl_Group(0, 50, 400, 170, "H/W ptt");
            o->tooltip("Tottle DTR for ptt");
            o->hide();
            { btnPTT[0] = new Fl_Round_Button(15, 70, 74, 17, "none");
              btnPTT[0]->down_box(FL_DIAMOND_DOWN_BOX);
              btnPTT[0]->value(1);
              btnPTT[0]->selection_color((Fl_Color)1);
              btnPTT[0]->callback((Fl_Callback*)cb_btnPTT);
              btnPTT[0]->hide();
            } // Fl_Round_Button* btnPTT[0]
            { btnPTT[4] = new Fl_Round_Button(245, 75, 20, 19, "use Serial Port h/w");
              btnPTT[4]->tooltip("PTT controlled via serial port");
              btnPTT[4]->down_box(FL_DIAMOND_DOWN_BOX);
              btnPTT[4]->selection_color((Fl_Color)1);
              btnPTT[4]->callback((Fl_Callback*)cb_btnPTT1);
              btnPTT[4]->align(FL_ALIGN_LEFT);
            } // Fl_Round_Button* btnPTT[4]
            { btnRTSptt = new Fl_Round_Button(100, 160, 54, 15, "RTS");
              btnRTSptt->tooltip("Toggle RTS for ptt");
              btnRTSptt->down_box(FL_DOWN_BOX);
              btnRTSptt->callback((Fl_Callback*)cb_btnRTSptt);
            } // Fl_Round_Button* btnRTSptt
            { btnDTRptt = new Fl_Round_Button(100, 180, 59, 15, "DTR");
              btnDTRptt->down_box(FL_DOWN_BOX);
              btnDTRptt->callback((Fl_Callback*)cb_btnDTRptt);
            } // Fl_Round_Button* btnDTRptt
            { btnRTSplusV = new Fl_Round_Button(172, 160, 87, 15, "RTS = +V");
              btnRTSplusV->tooltip("initial voltage on RTS");
              btnRTSplusV->down_box(FL_DOWN_BOX);
              btnRTSplusV->callback((Fl_Callback*)cb_btnRTSplusV);
            } // Fl_Round_Button* btnRTSplusV
            { btnDTRplusV = new Fl_Round_Button(172, 180, 87, 15, "DTR = +V");
              btnDTRplusV->tooltip("Initial voltage on DTR");
              btnDTRplusV->down_box(FL_DOWN_BOX);
              btnDTRplusV->callback((Fl_Callback*)cb_btnDTRplusV);
            } // Fl_Round_Button* btnDTRplusV
            { inpTTYdev = new Fl_Input_Choice(136, 113, 125, 22, "Port:");
              inpTTYdev->tooltip("Select serial port");
              inpTTYdev->callback((Fl_Callback*)cb_inpTTYdev);
            } // Fl_Input_Choice* inpTTYdev
            { btnInitHWPTT = new Fl_Button(275, 186, 113, 24, "Initialize");
              btnInitHWPTT->callback((Fl_Callback*)cb_btnInitHWPTT);
            } // Fl_Button* btnInitHWPTT
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 400, 170, "RigCAT");
            o->tooltip("Rig Control using xml spec file");
            o->hide();
            { chkUSERIGCAT = new Fl_Check_Button(110, 67, 20, 20, "use rigCAT");
              chkUSERIGCAT->tooltip("Select rigCAT for rig control");
              chkUSERIGCAT->down_box(FL_DOWN_BOX);
              chkUSERIGCAT->callback((Fl_Callback*)cb_chkUSERIGCAT);
            } // Fl_Check_Button* chkUSERIGCAT
            { btnPTT[3] = new Fl_Round_Button(242, 67, 128, 19, "command PTT");
              btnPTT[3]->tooltip("use PTT data command");
              btnPTT[3]->down_box(FL_DIAMOND_DOWN_BOX);
              btnPTT[3]->selection_color((Fl_Color)1);
              btnPTT[3]->callback((Fl_Callback*)cb_btnPTT2);
              btnPTT[3]->deactivate();
            } // Fl_Round_Button* btnPTT[3]
            { Fl_Output* o = txtXmlRigFilename = new Fl_Output(14, 94, 151, 22, "Xml File");
              txtXmlRigFilename->color(FL_LIGHT2);
              txtXmlRigFilename->align(FL_ALIGN_TOP_LEFT);
              o->value(fl_filename_name(progdefaults.XmlRigFilename.c_str()));
            } // Fl_Output* txtXmlRigFilename
            { btnSelectRigXmlFile = new Fl_Button(166, 93, 54, 24, "Select");
              btnSelectRigXmlFile->tooltip("Select xml file for your rig");
              btnSelectRigXmlFile->callback((Fl_Callback*)cb_btnSelectRigXmlFile);
            } // Fl_Button* btnSelectRigXmlFile
            { Fl_Input_Choice* o = inpXmlRigDevice = new Fl_Input_Choice(77, 122, 144, 22, "Port");
              inpXmlRigDevice->tooltip("Select the serial port");
              inpXmlRigDevice->callback((Fl_Callback*)cb_inpXmlRigDevice);
              o->value(progdefaults.XmlRigDevice.c_str());
            } // Fl_Input_Choice* inpXmlRigDevice
            { Fl_Choice* o = mnuXmlRigBaudrate = new Fl_Choice(122, 147, 99, 22, "Baud Rate");
              mnuXmlRigBaudrate->tooltip("Select the baud rate");
              mnuXmlRigBaudrate->down_box(FL_BORDER_BOX);
              mnuXmlRigBaudrate->callback((Fl_Callback*)cb_mnuXmlRigBaudrate);
              o->add(szBaudRates);
              o->value(progdefaults.XmlRigBaudrate);
            } // Fl_Choice* mnuXmlRigBaudrate
            { Fl_Round_Button* o = btnRigCatRTSptt = new Fl_Round_Button(242, 90, 70, 15, "rts PTT");
              btnRigCatRTSptt->tooltip("toggle RTS for ptt");
              btnRigCatRTSptt->down_box(FL_ROUND_DOWN_BOX);
              btnRigCatRTSptt->callback((Fl_Callback*)cb_btnRigCatRTSptt);
              o->value(progdefaults.RigCatRTSptt);
            } // Fl_Round_Button* btnRigCatRTSptt
            { Fl_Round_Button* o = btnRigCatDTRptt = new Fl_Round_Button(320, 90, 70, 15, "dtr PTT");
              btnRigCatDTRptt->tooltip("toggle DTR for ptt");
              btnRigCatDTRptt->down_box(FL_ROUND_DOWN_BOX);
              btnRigCatDTRptt->callback((Fl_Callback*)cb_btnRigCatDTRptt);
              o->value(progdefaults.RigCatDTRptt);
            } // Fl_Round_Button* btnRigCatDTRptt
            { Fl_Check_Button* o = btnRigCatRTSplus = new Fl_Check_Button(242, 110, 35, 15, "set RTS +12 v");
              btnRigCatRTSplus->tooltip("initial state of RTS");
              btnRigCatRTSplus->down_box(FL_DOWN_BOX);
              btnRigCatRTSplus->callback((Fl_Callback*)cb_btnRigCatRTSplus);
              o->value(progdefaults.RigCatRTSplus);
            } // Fl_Check_Button* btnRigCatRTSplus
            { Fl_Check_Button* o = btnRigCatDTRplus = new Fl_Check_Button(242, 130, 35, 15, "set DTR +12 v");
              btnRigCatDTRplus->tooltip("initial state of DTR");
              btnRigCatDTRplus->down_box(FL_DOWN_BOX);
              btnRigCatDTRplus->callback((Fl_Callback*)cb_btnRigCatDTRplus);
              o->value(progdefaults.RigCatDTRplus);
            } // Fl_Check_Button* btnRigCatDTRplus
            { Fl_Counter* o = cntRigCatRetries = new Fl_Counter(15, 188, 75, 21, "Retries");
              cntRigCatRetries->tooltip("# times to resend command before FAIL");
              cntRigCatRetries->type(1);
              cntRigCatRetries->minimum(1);
              cntRigCatRetries->maximum(10);
              cntRigCatRetries->step(1);
              cntRigCatRetries->value(5);
              cntRigCatRetries->callback((Fl_Callback*)cb_cntRigCatRetries);
              cntRigCatRetries->align(FL_ALIGN_TOP);
              o->value(progdefaults.RigCatRetries);
            } // Fl_Counter* cntRigCatRetries
            { Fl_Counter* o = cntRigCatTimeout = new Fl_Counter(102, 188, 75, 21, "Timeout");
              cntRigCatTimeout->tooltip("milliseconds between retries");
              cntRigCatTimeout->type(1);
              cntRigCatTimeout->minimum(2);
              cntRigCatTimeout->maximum(200);
              cntRigCatTimeout->step(1);
              cntRigCatTimeout->value(10);
              cntRigCatTimeout->callback((Fl_Callback*)cb_cntRigCatTimeout);
              cntRigCatTimeout->align(FL_ALIGN_TOP);
              o->value(progdefaults.RigCatTimeout);
            } // Fl_Counter* cntRigCatTimeout
            { Fl_Counter* o = cntRigCatWait = new Fl_Counter(190, 188, 75, 21, "Wait");
              cntRigCatWait->tooltip("Wait interval (msec) between commands");
              cntRigCatWait->type(1);
              cntRigCatWait->minimum(0);
              cntRigCatWait->maximum(100);
              cntRigCatWait->step(1);
              cntRigCatWait->value(5);
              cntRigCatWait->callback((Fl_Callback*)cb_cntRigCatWait);
              cntRigCatWait->align(FL_ALIGN_TOP);
              o->value(progdefaults.RigCatWait);
            } // Fl_Counter* cntRigCatWait
            { btnInitRIGCAT = new Fl_Button(275, 186, 113, 24, "Initialize");
              btnInitRIGCAT->tooltip("Initialize RigCAT interface");
              btnInitRIGCAT->callback((Fl_Callback*)cb_btnInitRIGCAT);
            } // Fl_Button* btnInitRIGCAT
            { Fl_Check_Button* o = chkRigCatRTSCTSflow = new Fl_Check_Button(242, 150, 70, 15, "RTS/CTS flow ctl.");
              chkRigCatRTSCTSflow->tooltip("RTS/CTS hardware flow control");
              chkRigCatRTSCTSflow->down_box(FL_DOWN_BOX);
              chkRigCatRTSCTSflow->callback((Fl_Callback*)cb_chkRigCatRTSCTSflow);
              o->value(progdefaults.RigCatRTSCTSflow);
            } // Fl_Check_Button* chkRigCatRTSCTSflow
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 400, 171, "Hamlib");
            o->hide();
            { chkUSEHAMLIB = new Fl_Check_Button(155, 65, 20, 20, "use Hamlib");
              chkUSEHAMLIB->tooltip("Select hamlib for rig control");
              chkUSEHAMLIB->down_box(FL_DOWN_BOX);
              chkUSEHAMLIB->callback((Fl_Callback*)cb_chkUSEHAMLIB);
              chkUSEHAMLIB->align(FL_ALIGN_LEFT);
            } // Fl_Check_Button* chkUSEHAMLIB
            { btnPTT[1] = new Fl_Round_Button(210, 65, 135, 20, "use Hamlib PTT");
              btnPTT[1]->tooltip("use PTT data command");
              btnPTT[1]->down_box(FL_DIAMOND_DOWN_BOX);
              btnPTT[1]->selection_color((Fl_Color)1);
              btnPTT[1]->callback((Fl_Callback*)cb_btnPTT3);
              btnPTT[1]->deactivate();
            } // Fl_Round_Button* btnPTT[1]
            { Fl_ComboBox* o = cboHamlibRig = new Fl_ComboBox(43, 90, 160, 22, "Rig:");
              cboHamlibRig->tooltip("Select hamlib rig");
              cboHamlibRig->box(FL_DOWN_BOX);
              cboHamlibRig->color(FL_BACKGROUND2_COLOR);
              cboHamlibRig->selection_color(FL_BACKGROUND_COLOR);
              cboHamlibRig->labeltype(FL_NORMAL_LABEL);
              cboHamlibRig->labelfont(0);
              cboHamlibRig->labelsize(14);
              cboHamlibRig->labelcolor(FL_FOREGROUND_COLOR);
              cboHamlibRig->callback((Fl_Callback*)cb_cboHamlibRig);
              cboHamlibRig->align(FL_ALIGN_LEFT);
              cboHamlibRig->when(FL_WHEN_RELEASE);
              o->readonly();
            } // Fl_ComboBox* cboHamlibRig
            { Fl_Input_Choice* o = inpRIGdev = new Fl_Input_Choice(59, 117, 144, 22, "Port:");
              inpRIGdev->tooltip("Select serial port");
              inpRIGdev->callback((Fl_Callback*)cb_inpRIGdev);
              o->value(progdefaults.HamRigDevice.c_str());
            } // Fl_Input_Choice* inpRIGdev
            { Fl_Choice* o = mnuBaudRate = new Fl_Choice(104, 144, 99, 22, "Baud Rate:");
              mnuBaudRate->tooltip("Select baud rate");
              mnuBaudRate->down_box(FL_BORDER_BOX);
              mnuBaudRate->callback((Fl_Callback*)cb_mnuBaudRate);
              o->add(szBaudRates);
              o->value(progdefaults.HamRigBaudrate);
            } // Fl_Choice* mnuBaudRate
            { btnInitHAMLIB = new Fl_Button(275, 186, 113, 24, "Initialize");
              btnInitHAMLIB->tooltip("Initialize Hamlib rig control");
              btnInitHAMLIB->callback((Fl_Callback*)cb_btnInitHAMLIB);
            } // Fl_Button* btnInitHAMLIB
            { Fl_Counter* o = cntHamlibtRetries = new Fl_Counter(15, 189, 75, 21, "Retries");
              cntHamlibtRetries->tooltip("# times to resend command before FAIL");
              cntHamlibtRetries->type(1);
              cntHamlibtRetries->minimum(1);
              cntHamlibtRetries->maximum(10);
              cntHamlibtRetries->step(1);
              cntHamlibtRetries->value(5);
              cntHamlibtRetries->callback((Fl_Callback*)cb_cntHamlibtRetries);
              cntHamlibtRetries->align(FL_ALIGN_TOP);
              o->value(progdefaults.HamlibRetries);
            } // Fl_Counter* cntHamlibtRetries
            { Fl_Counter* o = cntHamlibTimeout = new Fl_Counter(102, 189, 75, 21, "Timeout");
              cntHamlibTimeout->tooltip("milliseconds between retries");
              cntHamlibTimeout->type(1);
              cntHamlibTimeout->minimum(2);
              cntHamlibTimeout->maximum(200);
              cntHamlibTimeout->step(1);
              cntHamlibTimeout->value(10);
              cntHamlibTimeout->callback((Fl_Callback*)cb_cntHamlibTimeout);
              cntHamlibTimeout->align(FL_ALIGN_TOP);
              o->value(progdefaults.HamlibTimeout);
            } // Fl_Counter* cntHamlibTimeout
            { Fl_Counter* o = cntHamlibWait = new Fl_Counter(190, 189, 75, 21, "Wait");
              cntHamlibWait->tooltip("Wait interval (msec) between commands");
              cntHamlibWait->type(1);
              cntHamlibWait->minimum(0);
              cntHamlibWait->maximum(100);
              cntHamlibWait->step(1);
              cntHamlibWait->value(5);
              cntHamlibWait->callback((Fl_Callback*)cb_cntHamlibWait);
              cntHamlibWait->align(FL_ALIGN_TOP);
              o->value(progdefaults.HamlibWait);
            } // Fl_Counter* cntHamlibWait
            { Fl_Check_Button* o = btnHamlibDTRplus = new Fl_Check_Button(210, 93, 35, 15, "DTR +12");
              btnHamlibDTRplus->tooltip("initial state of DTR");
              btnHamlibDTRplus->down_box(FL_DOWN_BOX);
              btnHamlibDTRplus->callback((Fl_Callback*)cb_btnHamlibDTRplus);
              o->value(progdefaults.HamlibDTRplus);
            } // Fl_Check_Button* btnHamlibDTRplus
            { chkHamlibRTSplus = new Fl_Check_Button(300, 93, 35, 15, "RTS +12");
              chkHamlibRTSplus->tooltip("initial state of RTS");
              chkHamlibRTSplus->down_box(FL_DOWN_BOX);
              chkHamlibRTSplus->callback((Fl_Callback*)cb_chkHamlibRTSplus);
            } // Fl_Check_Button* chkHamlibRTSplus
            { Fl_Check_Button* o = chkHamlibRTSCTSflow = new Fl_Check_Button(210, 120, 70, 15, "RTS/CTS");
              chkHamlibRTSCTSflow->tooltip("RTS/CTS hardware flow control");
              chkHamlibRTSCTSflow->down_box(FL_DOWN_BOX);
              chkHamlibRTSCTSflow->callback((Fl_Callback*)cb_chkHamlibRTSCTSflow);
              o->value(progdefaults.HamlibRTSCTSflow);
            } // Fl_Check_Button* chkHamlibRTSCTSflow
            { Fl_Check_Button* o = chkHamlibXONXOFFflow = new Fl_Check_Button(300, 119, 70, 16, "XON/XOFF");
              chkHamlibXONXOFFflow->tooltip("XON/XOFF hardware flow control");
              chkHamlibXONXOFFflow->down_box(FL_DOWN_BOX);
              chkHamlibXONXOFFflow->callback((Fl_Callback*)cb_chkHamlibXONXOFFflow);
              o->value(progdefaults.HamlibXONXOFFflow);
            } // Fl_Check_Button* chkHamlibXONXOFFflow
            { inpHamlibConfig = new Fl_Input(210, 144, 176, 22);
              inpHamlibConfig->tooltip("Additional configuration\nof format: param=val ...");
              inpHamlibConfig->callback((Fl_Callback*)cb_inpHamlibConfig);
              inpHamlibConfig->value(progdefaults.HamConfig.c_str());
            } // Fl_Input* inpHamlibConfig
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 400, 170, "MemMap");
            { chkUSEMEMMAP = new Fl_Check_Button(255, 135, 20, 20, "use Memmap");
              chkUSEMEMMAP->tooltip("Select Memory Mapping rig control (Kachina)");
              chkUSEMEMMAP->down_box(FL_DOWN_BOX);
              chkUSEMEMMAP->callback((Fl_Callback*)cb_chkUSEMEMMAP);
              chkUSEMEMMAP->align(FL_ALIGN_LEFT);
            } // Fl_Check_Button* chkUSEMEMMAP
            { btnPTT[2] = new Fl_Round_Button(255, 155, 20, 20, "use Memmap PTT");
              btnPTT[2]->down_box(FL_DIAMOND_DOWN_BOX);
              btnPTT[2]->selection_color((Fl_Color)1);
              btnPTT[2]->callback((Fl_Callback*)cb_btnPTT4);
              btnPTT[2]->align(FL_ALIGN_LEFT);
              btnPTT[2]->deactivate();
            } // Fl_Round_Button* btnPTT[2]
            { Fl_Output* o = new Fl_Output(110, 74, 190, 58);
              o->type(12);
              o->box(FL_BORDER_BOX);
              o->color(FL_LIGHT1);
              o->value("Control via Memory Mapped\nshared variables\nie: Kachina program");
            } // Fl_Output* o
            { btnInitMEMMAP = new Fl_Button(275, 186, 113, 24, "Initialize");
              btnInitMEMMAP->callback((Fl_Callback*)cb_btnInitMEMMAP);
            } // Fl_Button* btnInitMEMMAP
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 401, 170, "XmlRpc");
            o->hide();
            { chkUSEXMLRPC = new Fl_Check_Button(281, 155, 20, 20, "use xmlrpc program");
              chkUSEXMLRPC->tooltip("experimental");
              chkUSEXMLRPC->down_box(FL_DOWN_BOX);
              chkUSEXMLRPC->callback((Fl_Callback*)cb_chkUSEXMLRPC);
              chkUSEXMLRPC->align(FL_ALIGN_LEFT);
            } // Fl_Check_Button* chkUSEXMLRPC
            { Fl_Output* o = new Fl_Output(120, 80, 190, 58);
              o->type(12);
              o->box(FL_BORDER_BOX);
              o->color(FL_LIGHT1);
              o->value("Rig control via external\nprogram using xmlrpc\nremote calls.");
            } // Fl_Output* o
            { btnInitXMLRPC = new Fl_Button(275, 186, 113, 24, "Initialize");
              btnInitXMLRPC->callback((Fl_Callback*)cb_btnInitXMLRPC);
            } // Fl_Button* btnInitXMLRPC
            o->end();
          } // Fl_Group* o
          o->end();
        } // Fl_Tabs* o
        tabRig->end();
      } // Fl_Group* tabRig
      { tabSoundCard = new Fl_Group(0, 25, 400, 195, "SndCrd");
        tabSoundCard->color((Fl_Color)51);
        tabSoundCard->selection_color((Fl_Color)51);
        tabSoundCard->hide();
        { tabsSoundCard = new Fl_Tabs(0, 25, 400, 195);
          tabsSoundCard->selection_color((Fl_Color)10);
          { tabAudio = new Fl_Group(0, 50, 400, 170, "Audio devices");
            tabAudio->color((Fl_Color)51);
            tabAudio->selection_color((Fl_Color)51);
            tabAudio->hide();
            { AudioOSS = new Fl_Group(5, 58, 391, 35);
              AudioOSS->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[0] = new Fl_Round_Button(5, 63, 53, 25, "OSS");
                btnAudioIO[0]->down_box(FL_DIAMOND_DOWN_BOX);
                btnAudioIO[0]->selection_color((Fl_Color)1);
                btnAudioIO[0]->callback((Fl_Callback*)cb_btnAudioIO);
              } // Fl_Round_Button* btnAudioIO[0]
              { Fl_Input_Choice* o = menuOSSDev = new Fl_Input_Choice(280, 63, 110, 25, "Device");
                menuOSSDev->callback((Fl_Callback*)cb_menuOSSDev);
                o->value(progdefaults.OSSdevice.c_str());
              } // Fl_Input_Choice* menuOSSDev
              AudioOSS->end();
            } // Fl_Group* AudioOSS
            { AudioPort = new Fl_Group(5, 95, 390, 61);
              AudioPort->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[1] = new Fl_Round_Button(5, 115, 95, 25, "PortAudio");
                btnAudioIO[1]->down_box(FL_DIAMOND_DOWN_BOX);
                btnAudioIO[1]->selection_color((Fl_Color)1);
                btnAudioIO[1]->callback((Fl_Callback*)cb_btnAudioIO1);
              } // Fl_Round_Button* btnAudioIO[1]
              { menuPortInDev = new Fl_Choice(165, 99, 225, 25, "Capture");
                menuPortInDev->down_box(FL_BORDER_BOX);
                menuPortInDev->callback((Fl_Callback*)cb_menuPortInDev);
              } // Fl_Choice* menuPortInDev
              { menuPortOutDev = new Fl_Choice(165, 127, 225, 25, "Playback");
                menuPortOutDev->down_box(FL_BORDER_BOX);
                menuPortOutDev->callback((Fl_Callback*)cb_menuPortOutDev);
              } // Fl_Choice* menuPortOutDev
              AudioPort->end();
            } // Fl_Group* AudioPort
            { AudioPulse = new Fl_Group(5, 158, 390, 32);
              AudioPulse->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[2] = new Fl_Round_Button(5, 159, 100, 30, "PulseAudio");
                btnAudioIO[2]->down_box(FL_DIAMOND_DOWN_BOX);
                btnAudioIO[2]->selection_color((Fl_Color)1);
                btnAudioIO[2]->callback((Fl_Callback*)cb_btnAudioIO2);
              } // Fl_Round_Button* btnAudioIO[2]
              { Fl_Input* o = inpPulseServer = new Fl_Input(165, 161, 225, 25, "Server");
                inpPulseServer->tooltip("Leave this blank or refer to\nhttp://www.pulseaudio.org/wiki/ServerStrings");
                inpPulseServer->callback((Fl_Callback*)cb_inpPulseServer);
                o->value(progdefaults.PulseServer.c_str());
              } // Fl_Input* inpPulseServer
              AudioPulse->end();
            } // Fl_Group* AudioPulse
            { AudioNull = new Fl_Group(5, 192, 390, 25);
              AudioNull->box(FL_ENGRAVED_FRAME);
              { btnAudioIO[3] = new Fl_Round_Button(5, 192, 100, 25, "File I/O only");
                btnAudioIO[3]->down_box(FL_DIAMOND_DOWN_BOX);
                btnAudioIO[3]->selection_color((Fl_Color)1);
                btnAudioIO[3]->callback((Fl_Callback*)cb_btnAudioIO3);
              } // Fl_Round_Button* btnAudioIO[3]
              AudioNull->end();
            } // Fl_Group* AudioNull
            tabAudio->end();
          } // Fl_Group* tabAudio
          { tabAudioOpt = new Fl_Group(0, 50, 400, 170, "Audio settings");
            tabAudioOpt->color((Fl_Color)51);
            tabAudioOpt->selection_color((Fl_Color)51);
            tabAudioOpt->hide();
            { Fl_Spinner* o = cntRxRateCorr = new Fl_Spinner(5, 160, 85, 25, "RX ppm");
              cntRxRateCorr->value(1);
              cntRxRateCorr->callback((Fl_Callback*)cb_cntRxRateCorr);
              cntRxRateCorr->align(FL_ALIGN_RIGHT);
              o->step(1);
              o->minimum(-50000);
              o->maximum(50000);
            } // Fl_Spinner* cntRxRateCorr
            { Fl_Spinner* o = cntTxRateCorr = new Fl_Spinner(5, 130, 85, 25, "TX ppm");
              cntTxRateCorr->value(1);
              cntTxRateCorr->callback((Fl_Callback*)cb_cntTxRateCorr);
              cntTxRateCorr->align(FL_ALIGN_RIGHT);
              o->step(1);
              o->minimum(-50000);
              o->maximum(50000);
            } // Fl_Spinner* cntTxRateCorr
            { Fl_Spinner* o = cntTxOffset = new Fl_Spinner(5, 190, 85, 25, "TX offset");
              cntTxOffset->value(1);
              cntTxOffset->callback((Fl_Callback*)cb_cntTxOffset);
              cntTxOffset->align(FL_ALIGN_RIGHT);
              o->value(progdefaults.TxOffset);
              o->step(1);
              o->minimum(-50);
              o->maximum(50);
            } // Fl_Spinner* cntTxOffset
            { AudioSampleRate = new Fl_Group(4, 58, 392, 62, "Sample rate");
              AudioSampleRate->box(FL_ENGRAVED_FRAME);
              AudioSampleRate->align(FL_ALIGN_TOP_RIGHT|FL_ALIGN_INSIDE);
              { Fl_Choice* o = menuOutSampleRate = new Fl_Choice(8, 91, 85, 25, "Playback");
                menuOutSampleRate->tooltip("Force a specific sample rate. Select \"Native\" if \"Auto\" does not work wel\
l with your sound hardware.");
                menuOutSampleRate->down_box(FL_BORDER_BOX);
                menuOutSampleRate->callback((Fl_Callback*)cb_menuOutSampleRate);
                menuOutSampleRate->align(FL_ALIGN_RIGHT);
                //extern Fl_Menu_Item sample_rate_menu[];
                //o->menu(sample_rate_menu);
                o->clear_changed();
              } // Fl_Choice* menuOutSampleRate
              { Fl_Choice* o = menuInSampleRate = new Fl_Choice(8, 62, 85, 25, "Capture");
                menuInSampleRate->tooltip("Force a specific sample rate. Select \"Native\" if \"Auto\" does not work wel\
l with your sound hardware.");
                menuInSampleRate->down_box(FL_BORDER_BOX);
                menuInSampleRate->callback((Fl_Callback*)cb_menuInSampleRate);
                menuInSampleRate->align(FL_ALIGN_RIGHT);
                //extern Fl_Menu_Item sample_rate_menu[];
                //o->menu(sample_rate_menu);
                o->clear_changed();
              } // Fl_Choice* menuInSampleRate
              { menuSampleConverter = new Fl_Choice(174, 91, 216, 25, "Converter");
                menuSampleConverter->down_box(FL_BORDER_BOX);
                menuSampleConverter->callback((Fl_Callback*)cb_menuSampleConverter);
                menuSampleConverter->align(FL_ALIGN_TOP_LEFT);
              } // Fl_Choice* menuSampleConverter
              AudioSampleRate->end();
            } // Fl_Group* AudioSampleRate
            tabAudioOpt->end();
          } // Fl_Group* tabAudioOpt
          { tabMixer = new Fl_Group(0, 50, 400, 170, "Mixer");
            tabMixer->color((Fl_Color)51);
            tabMixer->selection_color((Fl_Color)51);
            { btnLineIn = new Fl_Light_Button(295, 64, 74, 22, "Line In");
              btnLineIn->selection_color((Fl_Color)3);
              btnLineIn->callback((Fl_Callback*)cb_btnLineIn);
            } // Fl_Light_Button* btnLineIn
            { btnMicIn = new Fl_Light_Button(295, 94, 74, 22, "Mic In");
              btnMicIn->callback((Fl_Callback*)cb_btnMicIn);
            } // Fl_Light_Button* btnMicIn
            { valPCMvolume = new Fl_Value_Slider(19, 125, 340, 21, "PCM");
              valPCMvolume->type(5);
              valPCMvolume->color((Fl_Color)26);
              valPCMvolume->selection_color((Fl_Color)1);
              valPCMvolume->step(0.01);
              valPCMvolume->value(0.8);
              valPCMvolume->textsize(14);
              valPCMvolume->callback((Fl_Callback*)cb_valPCMvolume);
              valPCMvolume->align(FL_ALIGN_RIGHT);
            } // Fl_Value_Slider* valPCMvolume
            { Fl_Input_Choice* o = menuMix = new Fl_Input_Choice(105, 90, 110, 25, "Device");
              menuMix->callback((Fl_Callback*)cb_menuMix);
              o->value(progdefaults.MXdevice.c_str());
            } // Fl_Input_Choice* menuMix
            { Fl_Check_Button* o = btnMixer = new Fl_Check_Button(55, 61, 125, 25, "Manage mixer");
              btnMixer->down_box(FL_DOWN_BOX);
              btnMixer->callback((Fl_Callback*)cb_btnMixer);
              o->value(progdefaults.EnableMixer);
            } // Fl_Check_Button* btnMixer
            tabMixer->end();
          } // Fl_Group* tabMixer
          tabsSoundCard->end();
        } // Fl_Tabs* tabsSoundCard
        tabSoundCard->end();
      } // Fl_Group* tabSoundCard
      { tabUI = new Fl_Group(0, 25, 400, 195, "UI");
        tabUI->hide();
        { Fl_Tabs* o = new Fl_Tabs(0, 25, 400, 195);
          o->selection_color((Fl_Color)10);
          { tabUserInterface = new Fl_Group(0, 50, 400, 170, "General");
            { Fl_Group* o = new Fl_Group(5, 55, 390, 160);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnShowTooltips = new Fl_Check_Button(25, 80, 70, 15, "Show Tooltips");
                btnShowTooltips->tooltip("toggle tooltips on buttons, etc.");
                btnShowTooltips->down_box(FL_DOWN_BOX);
                btnShowTooltips->value(1);
                btnShowTooltips->callback((Fl_Callback*)cb_btnShowTooltips);
                o->value(progdefaults.tooltips);
              } // Fl_Check_Button* btnShowTooltips
              { Fl_Check_Button* o = chkMenuIcons = new Fl_Check_Button(25, 105, 70, 15, "icons on menus");
                chkMenuIcons->tooltip("toggle menu icons on/off");
                chkMenuIcons->down_box(FL_DOWN_BOX);
                chkMenuIcons->callback((Fl_Callback*)cb_chkMenuIcons);
                o->value(progdefaults.menuicons);
              } // Fl_Check_Button* chkMenuIcons
              { mnuScheme = new Fl_Choice(190, 75, 80, 25, "UI scheme");
                mnuScheme->tooltip("change application look and feel");
                mnuScheme->down_box(FL_BORDER_BOX);
                mnuScheme->callback((Fl_Callback*)cb_mnuScheme);
                mnuScheme->align(FL_ALIGN_RIGHT);
                mnuScheme->add("base");
                mnuScheme->add("gtk+");
                mnuScheme->add("plastic");
                mnuScheme->value(mnuScheme->find_item(progdefaults.ui_scheme.c_str()));
              } // Fl_Choice* mnuScheme
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(15, 125, 145, 80, "QSO logging");
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnNagMe = new Fl_Check_Button(25, 150, 80, 15, "Nag me");
                btnNagMe->tooltip("exit nag for unsaved log entries");
                btnNagMe->down_box(FL_DOWN_BOX);
                btnNagMe->callback((Fl_Callback*)cb_btnNagMe);
                o->value(progdefaults.NagMe);
              } // Fl_Check_Button* btnNagMe
              { Fl_Check_Button* o = btnClearOnSave = new Fl_Check_Button(25, 176, 125, 15, "Clear on Save");
                btnClearOnSave->tooltip("Clear log entries after saving or using macro <LOG>");
                btnClearOnSave->down_box(FL_DOWN_BOX);
                btnClearOnSave->callback((Fl_Callback*)cb_btnClearOnSave);
                o->value(progdefaults.ClearOnSave);
              } // Fl_Check_Button* btnClearOnSave
              o->end();
            } // Fl_Group* o
            tabUserInterface->end();
          } // Fl_Group* tabUserInterface
          { tabWfallRestart = new Fl_Group(0, 50, 400, 170, "Restart");
            tabWfallRestart->hide();
            { Fl_Group* o = new Fl_Group(5, 55, 390, 160, "These changes take effect on next program startup");
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
              { Fl_Counter* o = cntrWfwidth = new Fl_Counter(25, 83, 95, 21, "Waterfall width in Hz");
                cntrWfwidth->tooltip("Wider ==> higher cpu usage");
                cntrWfwidth->type(1);
                cntrWfwidth->minimum(2400);
                cntrWfwidth->maximum(4000);
                cntrWfwidth->step(100);
                cntrWfwidth->value(3000);
                cntrWfwidth->callback((Fl_Callback*)cb_cntrWfwidth);
                cntrWfwidth->align(FL_ALIGN_RIGHT);
                o->value(progdefaults.wfwidth);
              } // Fl_Counter* cntrWfwidth
              { Fl_Counter* o = cntrWfheight = new Fl_Counter(25, 109, 95, 21, "Waterfall height in pixels");
                cntrWfheight->tooltip("Taller ==> higher cpu usage");
                cntrWfheight->type(1);
                cntrWfheight->minimum(100);
                cntrWfheight->maximum(160);
                cntrWfheight->step(5);
                cntrWfheight->value(120);
                cntrWfheight->callback((Fl_Callback*)cb_cntrWfheight);
                cntrWfheight->align(FL_ALIGN_RIGHT);
                o->value(progdefaults.wfheight);
              } // Fl_Counter* cntrWfheight
              { Fl_Check_Button* o = btnDockedScope = new Fl_Check_Button(25, 136, 125, 20, "Docked scope");
                btnDockedScope->tooltip("Attach digiscope to right of waterfall");
                btnDockedScope->down_box(FL_DOWN_BOX);
                btnDockedScope->callback((Fl_Callback*)cb_btnDockedScope);
                o->value(progdefaults.docked_scope);
              } // Fl_Check_Button* btnDockedScope
              { Fl_Check_Button* o = btnDockedRigControl = new Fl_Check_Button(25, 161, 160, 20, "Docked Rig Control");
                btnDockedRigControl->tooltip("Attach rig control to left of logbook");
                btnDockedRigControl->down_box(FL_DOWN_BOX);
                btnDockedRigControl->value(1);
                btnDockedRigControl->callback((Fl_Callback*)cb_btnDockedRigControl);
                o->value(progdefaults.docked_rig_control);
              } // Fl_Check_Button* btnDockedRigControl
              { Fl_Check_Button* o = btnCheckButtons = new Fl_Check_Button(25, 187, 125, 20, "Check button toggle for Sql && AFC");
                btnCheckButtons->down_box(FL_DOWN_BOX);
                btnCheckButtons->callback((Fl_Callback*)cb_btnCheckButtons);
                o->value(progdefaults.useCheckButtons);
              } // Fl_Check_Button* btnCheckButtons
              o->end();
            } // Fl_Group* o
            tabWfallRestart->end();
          } // Fl_Group* tabWfallRestart
          o->end();
        } // Fl_Tabs* o
        tabUI->end();
      } // Fl_Group* tabUI
      { tabWaterfall = new Fl_Group(0, 25, 405, 195, "Wfall");
        tabWaterfall->color((Fl_Color)51);
        tabWaterfall->selection_color((Fl_Color)51);
        tabWaterfall->hide();
        { Fl_Tabs* o = new Fl_Tabs(0, 25, 405, 195);
          o->selection_color((Fl_Color)10);
          { Fl_Group* o = new Fl_Group(0, 50, 400, 170, "Filters/Colors");
            { Fl_Group* o = new Fl_Group(10, 84, 385, 96);
              o->box(FL_ENGRAVED_FRAME);
              { colorbox* o = WF_Palette = new colorbox(28, 107, 260, 24, "Palette:");
                WF_Palette->box(FL_DOWN_BOX);
                WF_Palette->color(FL_FOREGROUND_COLOR);
                WF_Palette->selection_color(FL_BACKGROUND_COLOR);
                WF_Palette->labeltype(FL_NORMAL_LABEL);
                WF_Palette->labelfont(0);
                WF_Palette->labelsize(14);
                WF_Palette->labelcolor(FL_FOREGROUND_COLOR);
                WF_Palette->callback((Fl_Callback*)cb_WF_Palette);
                WF_Palette->align(FL_ALIGN_TOP_LEFT);
                WF_Palette->when(FL_WHEN_RELEASE);
                o->label(progdefaults.PaletteName.c_str());
              } // colorbox* WF_Palette
              { btnColor[0] = new Fl_Button(20, 139, 20, 24);
                btnColor[0]->callback((Fl_Callback*)cb_btnColor);
              } // Fl_Button* btnColor[0]
              { btnColor[1] = new Fl_Button(52, 139, 20, 24);
                btnColor[1]->callback((Fl_Callback*)cb_btnColor1);
              } // Fl_Button* btnColor[1]
              { btnColor[2] = new Fl_Button(84, 139, 20, 24);
                btnColor[2]->callback((Fl_Callback*)cb_btnColor2);
              } // Fl_Button* btnColor[2]
              { btnColor[3] = new Fl_Button(116, 139, 20, 24);
                btnColor[3]->callback((Fl_Callback*)cb_btnColor3);
              } // Fl_Button* btnColor[3]
              { btnColor[4] = new Fl_Button(148, 139, 20, 24);
                btnColor[4]->callback((Fl_Callback*)cb_btnColor4);
              } // Fl_Button* btnColor[4]
              { btnColor[5] = new Fl_Button(180, 139, 20, 24);
                btnColor[5]->callback((Fl_Callback*)cb_btnColor5);
              } // Fl_Button* btnColor[5]
              { btnColor[6] = new Fl_Button(212, 139, 20, 24);
                btnColor[6]->callback((Fl_Callback*)cb_btnColor6);
              } // Fl_Button* btnColor[6]
              { btnColor[7] = new Fl_Button(244, 139, 20, 24);
                btnColor[7]->callback((Fl_Callback*)cb_btnColor7);
              } // Fl_Button* btnColor[7]
              { btnColor[8] = new Fl_Button(276, 139, 20, 24);
                btnColor[8]->callback((Fl_Callback*)cb_btnColor8);
              } // Fl_Button* btnColor[8]
              { btnLoadPalette = new Fl_Button(314, 107, 70, 24, "Load");
                btnLoadPalette->callback((Fl_Callback*)cb_btnLoadPalette);
              } // Fl_Button* btnLoadPalette
              { btnSavePalette = new Fl_Button(314, 139, 70, 24, "Save");
                btnSavePalette->callback((Fl_Callback*)cb_btnSavePalette);
              } // Fl_Button* btnSavePalette
              o->end();
            } // Fl_Group* o
            { Fl_Counter* o = cntLowFreqCutoff = new Fl_Counter(125, 55, 70, 20, "Low Freq Cutoff");
              cntLowFreqCutoff->type(1);
              cntLowFreqCutoff->minimum(0);
              cntLowFreqCutoff->maximum(500);
              cntLowFreqCutoff->step(50);
              cntLowFreqCutoff->value(300);
              cntLowFreqCutoff->callback((Fl_Callback*)cb_cntLowFreqCutoff);
              cntLowFreqCutoff->align(FL_ALIGN_LEFT);
              o->value(progdefaults.LowFreqCutoff);
            } // Fl_Counter* cntLowFreqCutoff
            { Fl_Check_Button* o = btnWFaveraging = new Fl_Check_Button(231, 57, 114, 15, "wf averaging");
              btnWFaveraging->down_box(FL_DOWN_BOX);
              btnWFaveraging->callback((Fl_Callback*)cb_btnWFaveraging);
              o->value(progdefaults.WFaveraging);
            } // Fl_Check_Button* btnWFaveraging
            { Fl_Group* o = new Fl_Group(10, 180, 385, 30);
              o->box(FL_ENGRAVED_FRAME);
              { btnWaterfallFont = new Fl_Button(20, 185, 120, 20, "Waterfall Font");
                btnWaterfallFont->callback((Fl_Callback*)cb_btnWaterfallFont);
              } // Fl_Button* btnWaterfallFont
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 49, 400, 170, "FFT Processing");
            o->hide();
            { Fl_Group* o = new Fl_Group(5, 58, 390, 42, "FFT Prefilter");
              o->box(FL_ENGRAVED_BOX);
              o->color((Fl_Color)51);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Check_Button* o = btnBlackman = new Fl_Check_Button(11, 78, 90, 15, "Blackman");
                btnBlackman->down_box(FL_DOWN_BOX);
                btnBlackman->callback((Fl_Callback*)cb_btnBlackman);
                if(progdefaults.wfPreFilter==1)o->value(1);else o->value(0);
              } // Fl_Check_Button* btnBlackman
              { Fl_Check_Button* o = btnHamming = new Fl_Check_Button(108, 78, 90, 15, "Hamming");
                btnHamming->down_box(FL_DOWN_BOX);
                btnHamming->callback((Fl_Callback*)cb_btnHamming);
                if(progdefaults.wfPreFilter==2)o->value(1);else o->value(0);
              } // Fl_Check_Button* btnHamming
              { Fl_Check_Button* o = btnHanning = new Fl_Check_Button(206, 78, 90, 15, "Hanning");
                btnHanning->down_box(FL_DOWN_BOX);
                btnHanning->callback((Fl_Callback*)cb_btnHanning);
                if(progdefaults.wfPreFilter==3)o->value(1);else o->value(0);
              } // Fl_Check_Button* btnHanning
              { Fl_Check_Button* o = btnTriangular = new Fl_Check_Button(304, 78, 90, 15, "Triangular");
                btnTriangular->down_box(FL_DOWN_BOX);
                btnTriangular->callback((Fl_Callback*)cb_btnTriangular);
                if(progdefaults.wfPreFilter==4)o->value(1);else o->value(0);
              } // Fl_Check_Button* btnTriangular
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(5, 105, 390, 50, "FFT Latency");
              o->box(FL_ENGRAVED_FRAME);
              o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
              { Fl_Counter* o = valLatency = new Fl_Counter(225, 119, 63, 21, "Scan merging:");
                valLatency->tooltip("1 = none");
                valLatency->type(1);
                valLatency->minimum(1);
                valLatency->maximum(8);
                valLatency->step(1);
                valLatency->value(4);
                valLatency->callback((Fl_Callback*)cb_valLatency);
                valLatency->align(FL_ALIGN_LEFT);
                o->value(progdefaults.latency);
              } // Fl_Counter* valLatency
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(5, 54, 393, 166, "Misc");
            o->hide();
            { Fl_Group* o = new Fl_Group(8, 60, 390, 158);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnUseCursorLines = new Fl_Check_Button(58, 70, 100, 20, "Cursor BW");
                btnUseCursorLines->down_box(FL_DOWN_BOX);
                btnUseCursorLines->callback((Fl_Callback*)cb_btnUseCursorLines);
                o->value(progdefaults.UseCursorLines);
              } // Fl_Check_Button* btnUseCursorLines
              { Fl_Check_Button* o = btnUseBWTracks = new Fl_Check_Button(58, 123, 100, 20, "BW Tracks");
                btnUseBWTracks->down_box(FL_DOWN_BOX);
                btnUseBWTracks->callback((Fl_Callback*)cb_btnUseBWTracks);
                o->value(progdefaults.UseBWTracks);
              } // Fl_Check_Button* btnUseBWTracks
              { Fl_Check_Button* o = btnUseCursorCenterLine = new Fl_Check_Button(58, 96, 121, 21, "Cursor Center");
                btnUseCursorCenterLine->down_box(FL_DOWN_BOX);
                btnUseCursorCenterLine->callback((Fl_Callback*)cb_btnUseCursorCenterLine);
                o->value(progdefaults.UseCursorCenterLine);
              } // Fl_Check_Button* btnUseCursorCenterLine
              { Fl_Button* o = btnCursorBWcolor = new Fl_Button(25, 70, 19, 20);
                btnCursorBWcolor->tooltip("Select Cursor BW color");
                btnCursorBWcolor->color((Fl_Color)3);
                btnCursorBWcolor->callback((Fl_Callback*)cb_btnCursorBWcolor);
                o->color(fl_rgb_color(progdefaults.cursorLineRGBI.R,progdefaults.cursorLineRGBI.G,progdefaults.cursorLineRGBI.B));
              } // Fl_Button* btnCursorBWcolor
              { Fl_Button* o = btnCursorCenterLineColor = new Fl_Button(25, 97, 19, 20);
                btnCursorCenterLineColor->tooltip("Select Center Line color");
                btnCursorCenterLineColor->color(FL_BACKGROUND2_COLOR);
                btnCursorCenterLineColor->callback((Fl_Callback*)cb_btnCursorCenterLineColor);
                o->color(fl_rgb_color(progdefaults.cursorCenterRGBI.R,progdefaults.cursorCenterRGBI.G,progdefaults.cursorCenterRGBI.B));
              } // Fl_Button* btnCursorCenterLineColor
              { Fl_Button* o = btnBwTracksColor = new Fl_Button(25, 124, 19, 20);
                btnBwTracksColor->tooltip("Select BW tracks color");
                btnBwTracksColor->color((Fl_Color)1);
                btnBwTracksColor->callback((Fl_Callback*)cb_btnBwTracksColor);
                o->color(fl_rgb_color(progdefaults.bwTrackRGBI.R,progdefaults.bwTrackRGBI.G,progdefaults.bwTrackRGBI.B));
              } // Fl_Button* btnBwTracksColor
              { Fl_Check_Button* o = chkShowAudioScale = new Fl_Check_Button(195, 70, 185, 20, "show Audio Scale");
                chkShowAudioScale->down_box(FL_DOWN_BOX);
                chkShowAudioScale->callback((Fl_Callback*)cb_chkShowAudioScale);
                o->value(progdefaults.wf_audioscale);
              } // Fl_Check_Button* chkShowAudioScale
              { Fl_Check_Button* o = btnViewXmtSignal = new Fl_Check_Button(26, 150, 135, 20, "View Tx Signal");
                btnViewXmtSignal->down_box(FL_DOWN_BOX);
                btnViewXmtSignal->callback((Fl_Callback*)cb_btnViewXmtSignal);
                o->value(progdefaults.viewXmtSignal);
              } // Fl_Check_Button* btnViewXmtSignal
              { Fl_Value_Slider* o = valTxMonitorLevel = new Fl_Value_Slider(25, 189, 340, 21, "Tx Audio Monitor Level");
                valTxMonitorLevel->type(5);
                valTxMonitorLevel->color((Fl_Color)26);
                valTxMonitorLevel->selection_color((Fl_Color)1);
                valTxMonitorLevel->step(0.05);
                valTxMonitorLevel->value(0.5);
                valTxMonitorLevel->textsize(14);
                valTxMonitorLevel->callback((Fl_Callback*)cb_valTxMonitorLevel);
                valTxMonitorLevel->align(FL_ALIGN_TOP_LEFT);
                o->value(progdefaults.TxMonitorLevel);
              } // Fl_Value_Slider* valTxMonitorLevel
              o->end();
            } // Fl_Group* o
            o->end();
          } // Fl_Group* o
          { Fl_Group* o = new Fl_Group(0, 50, 405, 166, "Mouse");
            o->hide();
            { Fl_Group* o = new Fl_Group(5, 56, 390, 158);
              o->box(FL_ENGRAVED_FRAME);
              { Fl_Check_Button* o = btnWaterfallHistoryDefault = new Fl_Check_Button(15, 66, 276, 20, "Left/Right click always replays history");
                btnWaterfallHistoryDefault->tooltip("Disabled - Ctrl-Lft click plays history");
                btnWaterfallHistoryDefault->down_box(FL_DOWN_BOX);
                btnWaterfallHistoryDefault->callback((Fl_Callback*)cb_btnWaterfallHistoryDefault);
                o->value(progdefaults.WaterfallHistoryDefault);
              } // Fl_Check_Button* btnWaterfallHistoryDefault
              { Fl_Check_Button* o = btnWaterfallQSY = new Fl_Check_Button(15, 96, 225, 20, "Dragging changes frequency");
                btnWaterfallQSY->tooltip("Drag mouse on waterfall scale to change frequency");
                btnWaterfallQSY->down_box(FL_DOWN_BOX);
                btnWaterfallQSY->callback((Fl_Callback*)cb_btnWaterfallQSY);
                o->value(progdefaults.WaterfallQSY);
              } // Fl_Check_Button* btnWaterfallQSY
              { inpWaterfallClickText = new Fl_Input(206, 120, 150, 50);
                inpWaterfallClickText->callback((Fl_Callback*)cb_inpWaterfallClickText);
                inpWaterfallClickText->align(FL_ALIGN_RIGHT);
              } // Fl_Input* inpWaterfallClickText
              { Fl_Check_Button* o = btnWaterfallClickInsert = new Fl_Check_Button(15, 134, 172, 20, "Insert text on left click");
                btnWaterfallClickInsert->tooltip("Default - double click on waterfall inserts text");
                btnWaterfallClickInsert->down_box(FL_DOWN_BOX);
                btnWaterfallClickInsert->callback((Fl_Callback*)cb_btnWaterfallClickInsert);
                o->value(progdefaults.WaterfallClickInsert);
              } // Fl_Check_Button* btnWaterfallClickInsert
              o->end();
            } // Fl_Group* o
            { mnuWaterfallWheelAction = new Fl_Choice(15, 176, 150, 22, "Wheel action");
              mnuWaterfallWheelAction->tooltip("Select how Mouse wheel behaves on waterfall");
              mnuWaterfallWheelAction->down_box(FL_BORDER_BOX);
              mnuWaterfallWheelAction->callback((Fl_Callback*)cb_mnuWaterfallWheelAction);
              mnuWaterfallWheelAction->align(FL_ALIGN_RIGHT);
            } // Fl_Choice* mnuWaterfallWheelAction
            o->end();
          } // Fl_Group* o
          o->end();
        } // Fl_Tabs* o
        tabWaterfall->end();
      } // Fl_Group* tabWaterfall
      tabsConfigure->end();
    } // Fl_Tabs* tabsConfigure
    { btnSaveConfig = new Fl_Button(145, 226, 113, 24, "Save Config");
      btnSaveConfig->callback((Fl_Callback*)cb_btnSaveConfig);
    } // Fl_Button* btnSaveConfig
    { btnCloseConfig = new Fl_Return_Button(280, 226, 113, 24, "Close");
      btnCloseConfig->callback((Fl_Callback*)cb_btnCloseConfig);
    } // Fl_Return_Button* btnCloseConfig
    o->end();
  } // Fl_Double_Window* o
  return w;
}

void openConfig() {
  if (!dlgConfig) createConfig();
progdefaults.loadDefaults();
}

void closeDialog() {
  if (dlgConfig) dlgConfig->hide();
}

void createConfig() {
  if (!dlgConfig) {
    dlgConfig = ConfigureDialog();
    dlgConfig->xclass(PACKAGE_NAME);
  }
}
